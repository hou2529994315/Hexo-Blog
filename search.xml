<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL(7) MySQL高级</title>
      <link href="2021-02-23-1.html"/>
      <url>2021-02-23-1.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h1><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>新安装的MySQL需要改为UTF-8编码，修改配置文件后不会改变已创建的数据库的字符集。</p><p>二进制日志文件 </p><ul><li>log-bin 用于主从复制</li><li>log-err 记录mysql的错误日志</li><li>查询日志log 用于记录查询的sql语句</li></ul><p>数据文件</p><ul><li>frm文件 存放表结构</li><li>myd文件 存放表数据</li><li>myi文件 存放表索引</li></ul><h2 id="MySQL架构介绍"><a href="#MySQL架构介绍" class="headerlink" title="MySQL架构介绍"></a>MySQL架构介绍</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210306145316.png"></p><blockquote><p>和其它数据库相比，MySQL有 点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，<strong>插件式的存储引擎架树将查询处理和其它的系统任务以及数据的存储提取相分离</strong>。这种架构可以<strong>根据业务的需求和实际需要选择合适的存储引擎</strong>。</p></blockquote><ul><li>连接层<br>最上层是客户端和连接服务，包含本地的socket和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信，完成连接处理、授权认证等安全方案。连接层上引入了连接池，为通过安全认证的客户端提供线程，在该层可实现SSL安全连接，服务器还会对每个安全接入的客户端进行验证，赋予操作权限。</li></ul><p>2 服务层<br>完成大多数的核心服务功能，如SQL接口，完成缓存的查询，SQL的分析优化及内置函数的执行，跨存储引擎的功能实现也在该层，如过程、函数等。在这一层，服务器会解析查询，并创建相应的内部解析树，完成相应的优化，如查询表的顺序、是否利用索引、最后生成相应的执行操作，如果是select操作，服务器会查询内部缓存，如果缓存的空间足够大，在解决大量的读环境中能很好的提升性能。</p><p>3 引擎层<br>存储引擎实现了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通讯，不同的存储引擎的特性不同，可根据需求选取，主要用到的是MyISAM和InnoDB。默认使用InnoDB。</p><p>4 存储层<br>将数据存储在裸设备的文件系统之上，并完成与存储引擎的交互。如NRFS,NFS等</p><h3 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h3><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>默认的存储引擎，支持外键、事务，行锁（适合高并发），缓存索引d的同时缓存真实数据，对内存的要求高，内存的大小对性能有决定性影响，表的空间大，更关注于事务，安装时默认安装该存储引擎。</p><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p>不支持外键、事务，采用表锁，在操作一条记录时也会锁住整张表，不适合并发场景，只缓存索引，不缓存真实数据。表空间小，更关注性能。安装时默认安装该存储引擎。</p><h4 id="Percona的XtraDB"><a href="#Percona的XtraDB" class="headerlink" title="Percona的XtraDB"></a>Percona的XtraDB</h4><p> Percona对MySQL进行了改进，使其在功能和性能上都有了很大的提升，使用XtraDB代替了InnoDB，在性能和并发上做的更好。阿里等公司使用该引擎，或进一步优化。</p><h2 id="索引优化分析"><a href="#索引优化分析" class="headerlink" title="索引优化分析"></a>索引优化分析</h2><h3 id="性能低的原因"><a href="#性能低的原因" class="headerlink" title="性能低的原因"></a>性能低的原因</h3><ul><li>查询语句不合理</li><li>索引失效<ul><li>单值索引</li><li>多值索引</li></ul></li><li>关联查询的join过多</li><li>服务器调优（缓冲、线程数等）</li></ul><h3 id="sql解析步骤"><a href="#sql解析步骤" class="headerlink" title="sql解析步骤"></a>sql解析步骤</h3><p><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210306151431.png"></p><h3 id="SQL的连接方式"><a href="#SQL的连接方式" class="headerlink" title="SQL的连接方式"></a>SQL的连接方式</h3><ul><li><p>内连接<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210306151702.png"></p></li><li><p>左连接<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210306151757.png"></p></li><li><p>右连接<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210306151829.png"></p><ul><li><p>左连接去重<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210306152051.png"></p></li><li><p>右连接去重<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210306152159.png"></p></li></ul></li><li><p>全连接（MySQL不支持）<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210306152344.png"></p></li></ul><p>由于MySQL不支持，所以使用左连接+右连接+union去重实现全连接的查询需求。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tab_a <span class="token keyword">left</span> <span class="token keyword">join</span> tab_b <span class="token keyword">on</span> <span class="token number">a</span><span class="token punctuation">.</span>depId <span class="token operator">=</span> <span class="token number">b</span><span class="token punctuation">.</span>id <span class="token keyword">union</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tab_a <span class="token keyword">right</span> <span class="token keyword">join</span> tab_b <span class="token keyword">on</span> <span class="token number">a</span><span class="token punctuation">.</span>depId <span class="token operator">=</span> <span class="token number">b</span><span class="token punctuation">.</span>id<span class="token punctuation">;</span> </code></pre><ul><li>特点<br>左连接、右连接会自动补NULL</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引（Index）是帮助MySQL高效获取数据的数据结构，排好序的快速查找数据结构。<br>索引的本质是数据结构<br><strong>索引的目的：提高查找效率</strong></p><ul><li><p>优点：</p><ul><li>提高数据检索的效率，降低数据库的I0成本</li><li>降低数据排序的成本，降低了CPU的消耗</li></ul></li><li><p>缺点：</p><ul><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的</li><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT. UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息</li><li>索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就<strong>需要花时间研究建立最优秀的索引</strong>，或优化查询语句</li></ul></li><li><p>索引会影响查找和排序的效率</p></li><li><p>主键本身也是索引</p></li><li><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构通过引用（指针）的方式引用数据，这样就可以在此数据结构的基础上实现高级算法，这种数据结构就是索引。</p></li></ul><p>*一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。</p><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><ul><li>Btree</li><li>Hash索引</li><li>full-text全文索引</li><li>R-Tree索引</li></ul><p>如果没有特别说明，所说的索引都指B树结构组织的索引。聚集索引、次要索引、复合索引、前缀索引、唯一索引都默认使用B+树索引，统称索引。出了B+树索引，还有哈希索引</p><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><ul><li><p>单值索引：即一个索引只包含单个列，一个表可以有多个单列索引</p></li><li><p>唯一索引：索引列的值必须唯一， 但允许有空值</p></li><li><p>复合索引：即一个索引包含多个列</p></li><li><p>操作</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 创建</span><span class="token keyword">CREATE</span> <span class="token punctuation">[</span><span class="token keyword">UNIQUE</span> <span class="token punctuation">]</span> <span class="token keyword">INDEX</span> indexName <span class="token keyword">ON</span> mytable<span class="token punctuation">(</span>columnname<span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">ALTER</span> mytable <span class="token keyword">ADD</span> <span class="token punctuation">[</span><span class="token keyword">UNIQUE</span> <span class="token punctuation">]</span> <span class="token keyword">INDEX</span> <span class="token punctuation">[</span>indexName<span class="token punctuation">]</span> <span class="token keyword">ON</span> <span class="token punctuation">(</span>columnname<span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#删除</span><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> <span class="token punctuation">[</span>indexName<span class="token punctuation">]</span> <span class="token keyword">ON</span> mytable<span class="token punctuation">;</span><span class="token comment" spellcheck="true">#查看</span><span class="token keyword">SHOW</span> <span class="token keyword">INDEX</span> <span class="token keyword">FROM</span> table_ name\G</code></pre></li></ul><h3 id="何时创建索引"><a href="#何时创建索引" class="headerlink" title="何时创建索引"></a>何时创建索引</h3><h4 id="需要创建索引"><a href="#需要创建索引" class="headerlink" title="需要创建索引"></a>需要创建索引</h4><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其它表关联的字段，外键关系建立索引</li><li>频繁更新的字段不适合创建索引，因为每次更新不单单是更新了记录还会更新索引，加重了I0负担</li><li> Where条件里用不到的字段不创建索引</li><li>单键/组合索引的选择问题，who?(在高并发下倾向创建组合索引)</li><li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。</li><li>查询中统计或者分组字段表记录太少.</li></ol><h4 id="不创建索引"><a href="#不创建索引" class="headerlink" title="不创建索引"></a>不创建索引</h4><ol><li>表记录太少（300万左右性能开始下降）<br>Why:提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。</li><li>经常增删改的表<br>因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件</li><li>数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。<br>注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</li></ol><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><h4 id="MySQL-Query-Optimizer-查询优化器"><a href="#MySQL-Query-Optimizer-查询优化器" class="headerlink" title="MySQL Query Optimizer(查询优化器)"></a>MySQL Query Optimizer(查询优化器)</h4><ul><li>MySQL中有专门负责优化SELECT语句的优化器模块，该模块主要通过计算分析系统中手机的统计信息，为客户端请求的Query提供他人为最优的执行计划（但是他认为最优的检索方式不见得是DBA人为最优的）</li><li>当客户端向MySQL请求一条Query时，命令解析器模块完成请求分类，区别出是SELECT并转发给MySQL Query Optimizer时，MySQL Query Optimizer首先对整条Query中的查询条件进行简化和转换，如去掉一些无用或者显而易见的条件、结构调整等，然后分析Query中的Hint信息（如果有）,看监视Hint信息是否可以完全确定Query的执行计划，如果没有Hint或Hint信息不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据Query进行谐响应的计算分析，然后得出最后的执行计划。</li></ul><h4 id="MySQL的常见瓶颈"><a href="#MySQL的常见瓶颈" class="headerlink" title="MySQL的常见瓶颈"></a>MySQL的常见瓶颈</h4><ul><li>CPU：CPU饱和的时候一般发生在数据装入内存或从磁盘上读取数据的时候</li><li>IO：磁盘的IO瓶颈发生在装入数据远大于内存容量的时候</li><li>服务器硬件的性能瓶颈：top，free，iostat，vmstat来查看系统的性能状态</li></ul><h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>​ 使用Explain关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的，分析查询语句或是表结构的性能瓶颈。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>查看表的读取顺序（id，table字段）</li><li>展现数据读取操作的操作类型（select_type）</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4>​ Explain + SQL语句，得到分析结果</li></ul><p><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210306191015.png"></p><p><strong>包含的信息</strong></p><ul><li><p><strong>id</strong><br>select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序，NULL最后执行。</p><ul><li>id相同，执行顺序由上至下（table字段）</li><li>id不同，如果是子查询，id的序列号会递增，id值越大，所对应的table字段的表越先执行。</li><li>id相同和不同：id值越大，优先级越高，越先执行，id相同的部分是一组，从上往下执行。<br>注：table中的derivedx表示衍生表，x代表由谁执行后衍生的。<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210306191613.png"></li></ul></li><li><p><strong>select_type</strong><br>数据读取操作的操作类型</p><ul><li>SIMPLE : 简单的select查询，查询中不包含子查询或UNION</li><li>PRIMARY : 查询中若包含任何复杂的子部分时，最外层查询被标记为子查询（最后加载的那个）</li><li>SUBQUERY : 在SELECT或WHERE列表中包含了子查询</li><li>DERIVED : 在FROM列表中包含的子查询被标记为DERIVED（衍生表），MySQL会递归执行这些子查询，把结果放在临时表中。</li><li>UNION : 若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为DERIVED</li><li>UNION RESULT : 从UNION表获取结果的SELECT</li></ul></li><li><p><strong>table</strong><br>表示是哪一张表</p></li><li><p><strong>type</strong><br>访问类型排列，显示了查询使用了哪种类型，从好到差的排列顺序为：<strong>systerm &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</strong></p></li></ul><p>ALL表示全表扫描，一般来说至少达到range级别，最好能达到ref。<br>    1. systerm：表只有一行记录（等于系统表），是const类型的特例，平时不会出现，可忽略不计<br>    2. const：表示通过索引一次就找到了，const用来比较primary key或unique索引，因为只匹配一行数据，所以很快，如果将主键至于WHERE列表中，MySQL就将该查询转换为一个常量。<br>    3. eq_ref：唯一性索引扫描，对于每个索引键，<strong>表中只有一条记录与之匹配</strong>，常见于主键或唯一索引扫描。（只有一条符合匹配）<br>    4. ref：非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回<strong>所有匹配某个单独值的所有行</strong>，然而它可能会找到多个符合条件得行，所以它应该属于查找和扫描得混合体。（有多条符合匹配）<br>    5. range：只检索给定范围得行，使用一个索引来选择行，key列表显示了使用了哪些索引。<strong>一般就是在你得where语句中出现了between、&lt;、&gt;、in等得查询</strong>。这种范围扫描索引比全表扫描要好，因为<strong>它只需要开始于索引得某一个点</strong>，而不用扫描全部索引。（如id大于多少、小于多少）<br>    6. index：Full Index Scan ,index于All的区别为index只遍历索引树。这通常要比ALL快，因为索引文件通常要比数据文件小。也就是说，虽然All和index都是读全表，但是index是从索引中读取的，而all是从硬盘中读取的。<br>    7. all：全表扫描</p><ul><li><p><strong>possible_keys</strong><br>显示可能用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但在该查询中不一定被使用到。</p></li><li><p><strong>key</strong><br>表示实际使用到的索引，如果位NULL则表示没有使用索引</p></li></ul><p>查询中若使用到了覆盖索引，则该索引仅出现在key列表中。</p><p>sql执行时全索引扫面，<strong>如果发现selec查询的字段和顺序和建复合索引时使用的字段一致，就会使用该索引，此时产生覆盖索引</strong></p><blockquote><p>覆盖索引： select的数据列只用从索引中取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取文件，即查询列要被所建的索引覆盖。<br>因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降。</p></blockquote><p>如果用到覆盖索引，select列表中只取出需要的列，不可<code>select * </code></p><ul><li><p><strong>key_len</strong><br>表示索引中使用的字节数，可通过该列计算查询中使用的索引长度，在不损失精度的情况下，长度越短越好。（在建了索引的前提下，查询条件越精确，key_len的值越大）<br>​key_len显示的值为索引字段的最大可能长度，并非实际使用长度，该值是根据表定义计算得到，不是通过表内检索出来的。</p></li><li><p><strong>ref</strong><br>​显示索引的哪一列被使用了（索引的具体引用情况），如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。格式为（库名.表名.字段名 或 const）</p></li><li><p><strong>rows</strong><br>表示每张表有多少行被优化器查询过（加起来越少越好）。</p></li><li><p><strong>Extra（重要）</strong><br>包含不适合在其他列显示，但十分重要的额外信息。</p></li></ul><ol><li><p>☆ Using filesort：说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引排序进行读取，MySQL无法利用索引完成的排序操作称为“文件排序”，需要尽快优化。MySQL自己在内部产生了一次排序，<strong>会导致性能下降</strong>。因此尽可能的使用原本创建好的索引和索引的顺序。</p></li><li><p>☆ Using temporary：使用了临时表保存中间结果，MySQl在对中间结果排序时使用临时表，常见于排序order by 和分组查询 group by。（一定要赶紧优化，需要见表、删表、性能急速下降,如下图）<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210306214504.png"></p></li><li><p>☆ Using index：</p><ul><li>表示相应的select操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错。</li><li>如果同时出现using where ，表明索引被用来执行索引键值的查找</li><li>如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。</li></ul></li><li><p>Using where：表明使用了where过滤</p></li><li><p>Using join buffer：使用了连接缓存</p></li><li><p>impossible where：where子句的值总是false，不能用来获取任何元组</p></li><li><p>select tables optimized away（了解）：在没有GROUP BY 子句的情况下，基于索引优化MIN/MAX操作或者对于M有ISAM存储引擎优化COUNT（*）操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即可完成优化。</p></li><li><p>distinct（了解）：优化distinct操作，在找到第一匹配的元组胡即停止找同样值得动作。 </p></li></ol><h3 id="索引的建立与优化"><a href="#索引的建立与优化" class="headerlink" title="索引的建立与优化"></a>索引的建立与优化</h3><h4 id="索引分析"><a href="#索引分析" class="headerlink" title="索引分析"></a>索引分析</h4><ul><li><p>单表<br>范围需求字段建了索引以后，其后的索引会失效，降低效率。</p></li><li><p>两表<br>以左连接为例，左连接在右表建立索引。<br>原因：左连接时左表一定全要，从右表中搜索，此时要在右表建立索引可以提高搜索效率。</p></li><li><p>三表<br>依然按照两表中的原则，索引最好设置在需要经常查询的字段中。<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210307133135.png"></p></li></ul><blockquote><p>结论</p><blockquote><p>尽可能减少Join语句中的NestedLoop的循环总次数，永远用小表驱动大表。<br>优先优化NestedLoop(嵌套循环)的内层循环<br>保证Join语句中被驱动表上Join条件字段已经被索引<br>当无法把凭证被驱动表的Join条件字段被索引且内存资源充足的前提下，不要太吝啬JoinBuffer的设置。</p></blockquote></blockquote><h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><ul><li><p><strong>什么是索引失效</strong></p></li><li><p><strong>如何避免</strong></p><ol><li>全值匹配我最爱</li><li>最佳左前缀法则 ——如果索引了多列(a,b,c)，要遵守最左前缀法则。指的是查询从索引的最左前列开始并A不跳过索引中的列。</li><li>不在索引列上做任何操作(计算、函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描</li><li>存储引擎不能使用索引中范围条件右边的列(范围之后全失效)</li><li>尽量使用覆盖索引(只访问索引的查询(索引列和查询一致)，减少<code>select *</code></li><li>mysql在使用不等于(!=或者&lt;&gt; )的时候无法使用索引会导致全表扫描</li><li>is null ,is not null也无法使用索引(所以尽量不设置空值，而是设置为-1这类不可能出现的值)</li><li>like以通配符开头(‘%xyz…’)mysq|索引失效会变成全表扫描的操作——问题:解决like%字符串%”时索引不被使用的方法??</li><li>字符串不加单引号索引失效（隐式类型转换，见第三条）</li><li>少用or,用它来连接时会索引失效<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210307143324.png"><br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210307145125.png"></li></ol></li><li><p><strong>一般性建议</strong></p></li><li><p>对于单键索引，尽量选择针对当前query过滤性更好的索引</p></li><li><p>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好</p></li><li><p>在选择组合索引的时候，尽量选择可以能够包含当前query中的where子句中更多字段的索引。</p></li><li><p>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的。</p></li><li><p><strong>其它</strong></p><ul><li>如果有复合索引a1, a2, a3使用了<code>where a3=b3 and a2 = b2 and a1 = b1</code>,MySQL的优化器会自动优化，将字段顺序修改为索引字段的顺序，这样就可以覆盖索引了</li><li>索引用于<strong>查找</strong>和<strong>排序</strong>，<code>&gt;, &lt;, order by</code>都会用到索引进行排序</li></ul></li></ul><blockquote><p>最佳左前缀法则<br>带头大哥不能死，中间兄弟不能断<br>第一个断了，直接失效。中间的断了，只能在断掉之前的部分使用索<br>引</p></blockquote><blockquote><p>尽量使用覆盖索用，让索引列和查询列一致，这样可以保证 <code>Using index</code></p></blockquote><blockquote><p>%最好加载右边，不可以加在左边，如果非要用’%abc%’，建议使用覆盖索引，即select 后的字段全部在某个索引内。可以从ALL提升到index。</p></blockquote><h2 id="查询截取分析"><a href="#查询截取分析" class="headerlink" title="查询截取分析"></a>查询截取分析</h2><h3 id="分析优化过程"><a href="#分析优化过程" class="headerlink" title="分析优化过程"></a>分析优化过程</h3><ul><li>观察，至少跑一天，看看生产中慢SQL的情况</li><li>开启慢查询日志，设置阈值，比如超过5秒的SQL语句，并抓取</li><li>explain + 慢SQL分析</li><li>show profile，查询SQL在MySQL服务器里面的执行细节和生命周期情况</li><li>DBA进行SQL数据库服务器的参数调优</li></ul><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><ul><li><strong>永远小表驱动大表</strong><ul><li>即小的数据集，驱动大的数据集，从而减少IO次数，</li><li>B表的数据集小于A表时，用in优于exists</li><li>A表的数据集小于B表时，用exists优于in</li></ul></li></ul><p><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210307150023.png"></p><blockquote><p>EXISTS<br>SELECT … FROM table WHERE EXISTS (subquery)<br>该语法可以理解为:将主查询的数据，放到子查询中做条件验证，根据验证结果(TRUE或FALSE)来决定主查询的数据结果是否得以保留,subquery子查询中的<code>SELECT *</code>也可以是<code>SELECT 1</code>或<code>SELECT ‘X’</code>，官方说法是实际执行时会忽略SELECT清单，因此没区别</p></blockquote><h4 id="order-by关键字优化"><a href="#order-by关键字优化" class="headerlink" title="order by关键字优化"></a>order by关键字优化</h4><p>尽量不要产生filesort</p><ul><li><p><strong>最佳左前缀原则依然有效</strong></p><ul><li>order by后所用的索引要按照创建的顺序，不能间断，否则会产生文件排序。跟前面的内容无关。</li><li>默认是升序，如果同时使用降序和升序，即使按照索引顺序，也会导致文件排序。除非所有索引都降序，且按照索引顺序，就不会产生文件排序。</li></ul></li><li><p><strong>filesort排序算法</strong><br>双路排序：MySQL4.1之前使用的是该算法，取一批数据需要进行两次扫描。<br>单路排序：4.1版本以后采用单路算法，一次读取，在buffer中排序，只用读一次，总体好于双路排序。<br>结论：<strong>单路排序可能会因为sort_buffer的太小产生多次IO</strong>，还不如双路排序，因此需要进行相应的配置。</p></li><li><p><strong>提升性能方法</strong></p><ul><li><p>order by 就尽量不要SELECT *，因为如果产生了filesort就会增加缓存，把sort_buffer_size给用满了，导致产生多次IO。</p></li><li><p>有filesort可尝试提高sort_buffer_size，根据系统能力去提高，该参数针对每个进程。</p></li><li><p>有filesort可尝试提高max_length_for_sort_data，太大，数据总量超过sort_buffer_size会导致高的磁盘IO和低的处理器利用率。</p><p><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210307154137.png"></p></li></ul></li></ul><h4 id="group-by关键字优化"><a href="#group-by关键字优化" class="headerlink" title="group by关键字优化"></a>group by关键字优化</h4><p>group by 的实质是先排序后分组，遵照索引建的最佳左前缀，当无法使用索引列，增大sort_buffer_size 和 max_length_for_sort_data的参数设置，</p><p>where高于having ，因此能写在where里的条件就不要到having中去限制。</p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>MySQl的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过 long_query_time值得SQL，则会记录在慢查询日志中。</li><li>long_query_time得默认值是10，即10秒钟</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ul><li><p>默认MySQL数据库没有开启，需要我们手动得开启慢查询日志。非调优需要不建议开启，因为开启慢查询会多少对性能造成影响，慢查询日志支持将日志写入文件。</p></li><li><p>命令：</p><ul><li><code>SHOW VARIABLES LIKE &#39;%slow_query_log%&#39;</code>; 查看是否开启及存储文件</li><li><code>set global show_query_log=1; </code>开启慢查询（只对当前数据库有效，重启后就会失效）</li><li><code>set global long_query_time=3;</code> 设置阈值为3 （本库有效，重启无效，重开一个连接通过show才能查到）</li><li><code>SHOW global status like &#39;%Slow_queries%&#39;;</code> 查询日志的条数</li></ul></li><li><p>永久开启（不建议）<br>  修改my.cnf在[mysqld]下增加或修改参数<br>  slow_query_log=1<br>  slow_query_log_file=/var/lib/mysql/xxx.log (缺省得文件名为主机+slow.log)<br>  long_query_time = 3<br>  log_output=FILE<br>  执行测试</p></li></ul><p>可通过select sleep(5); 等方式来执行语句，这样如果阈值低于5秒，该语句会被记录。</p><h4 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h4><p>在生产中，手工分析日志比较麻烦，因此MySQL提供了日志分析工具，mysqldumpslow。</p><h4 id="批量数据脚本"><a href="#批量数据脚本" class="headerlink" title="批量数据脚本"></a>批量数据脚本</h4><p>开启二进制方法创建<br>创建函数，保证每条数据都不同<br>创建存储函数，一次插入批量数据<br>调用函数</p><h3 id="Show-Profile"><a href="#Show-Profile" class="headerlink" title="Show Profile"></a>Show Profile</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Show Profile是mySQL提供的可以用来分析当前会话中语句执行的资源消耗情况，可以用于SQL的调优测量，默认是关闭状态，并保存最近15次的运行结果。</p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul><li><code>show variables like &#39;profiling;&#39; </code>查看是否开启</li><li><code>set profiling=on; </code>打开profile</li><li><code>show profiles;</code> 查看执行过的SQL，包含执行时间和SQL语句、查询ID信息。</li><li><code>show profile cpu,block io for query 查询ID;</code> 列出上面某个查询的详细过程信息。<strong>一条SQL的完整生命周期</strong>。</li></ul><h3 id="全局查询日志"><a href="#全局查询日志" class="headerlink" title="全局查询日志"></a>全局查询日志</h3><p>只能在测试环境用，不能在生产环境用。</p><h2 id="MySQL锁机制"><a href="#MySQL锁机制" class="headerlink" title="MySQL锁机制"></a>MySQL锁机制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>锁是计算机协调多个进程或线程并发访问某一资源的机制</p><p>在数据库中，除传统的CPU、RAM、IO等资源的征用以外，数据也是一种很多用户共享的资源，如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是并发访问性能的一个重要的因素，锁对于数据库尤为的重要，也更复杂。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>操作类型分类<ul><li>读锁（共享锁）：针对同一份数据，多个读操作可同时进行，互不影响</li><li>写锁（排他锁）：当前写操作未完成之前，会阻断其他的写锁和读锁。</li></ul></li><li>操作颗粒度分类<ul><li>表锁</li><li>行锁</li></ul></li></ul><h3 id="MySQL的锁机制"><a href="#MySQL的锁机制" class="headerlink" title="MySQL的锁机制"></a>MySQL的锁机制</h3><h4 id="表锁（偏读）"><a href="#表锁（偏读）" class="headerlink" title="表锁（偏读）"></a>表锁（偏读）</h4><p>偏向于MyISAM存储引擎，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率最高，并发度低。<br>MyISQM在执行select前会对所涉及的表加读锁，在执行增删改之前，会对涉及的表加写锁。</p><ul><li><p>命令</p><ul><li><code>show open tables; </code>查看表上加过的锁，0未锁</li><li><code>lock table 表名 read(write); </code>给表加读锁或者写锁</li><li><code>unlock tables; </code>解除库中所有的锁</li></ul></li><li><p>注意点（针对MyISAM引擎）：</p><ul><li>加表的<strong>读锁</strong>以后，只能读该表，不能读其他表或写这个表，一定要解除了自己加的这个锁以后才能做其他操作。其他连接要进行写操作要被堵塞。</li><li>对表加<strong>写锁</strong>后，该连接可读、改自己锁的表，同样在没有解锁前不能操作其他表。<strong>其他表对该表查询和写同样阻塞</strong>。</li><li>当前会话不解锁，其它操作该表的会话就会一直等待。<blockquote><p>注意： MyISAM的读写锁调度是写优先，因此不适合作为写为主的情况，写锁后其他线程不能做任何操作，大量更新会使查询很难得到锁，从而造成永远阻塞。</p></blockquote></li></ul></li></ul><h4 id="行锁（偏写）"><a href="#行锁（偏写）" class="headerlink" title="行锁（偏写）"></a>行锁（偏写）</h4><p>偏向于InnoDB引擎，开销大、加锁慢，会出现死锁，锁的粒度小，发生冲突的可能小，并发高。InnoDB支持事务，并采用了行锁。 （复习事务的隔离级别，和数据库事务。）</p><ul><li><p><strong>行锁变表锁</strong></p></li><li><p>*索引失效会导致行锁变表锁**，常出现索引失效就是自动类型转换，即varchar数据不加单引号。这时操作数据会导致索引失效，操作过程锁住整个表。</p></li><li><p><strong>间隙锁危害</strong><br>当我们用范围条件而不是相等条件去检索数据的时候，并请求共享和排他锁时，InnoDB会给符合条件的已有数据的索引加索，对于键值在条件范围内但不存在的记录，叫做间隙（GAP）。<br>​当锁定一个范围的键值以后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候，无法插入锁定范围内的任何数据</p></li></ul><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。<br>但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</p><h4 id="优化分析"><a href="#优化分析" class="headerlink" title="优化分析"></a>优化分析</h4><ul><li><code>show status like &#39;innodb_row_lock&#39;;</code> 查看行锁的状态</li><li><code>innodb_row_lock_current_waits</code>: 当前正在等待的锁的数量</li><li><code>innodb_row_lock_time</code>： 从系统锁定到现在锁定的总时间长度</li><li><code>innodb_row_lock_time_max</code>： 从系统锁定到现在锁定最长的一次所花时间</li><li><code>innodb_row_lock_time_avg</code>： 从系统锁定到现在锁定的平均时长</li><li><code>innodb_row_lock_waits</code>：系统启动后到现在总共等待的次数</li></ul><h4 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h4><ul><li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</li><li>合理设计索引，尽量缩小锁的范围</li><li>尽可能减少检索条件，避免间隙锁</li><li>尽量控制事务大小，减少锁定资源量和时间长度</li><li>尽可能低级别事务隔离。</li></ul><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h3><ol><li>master将改变记录到二进制日志（binary log）中，这些日志叫做二进制日志事件，<code>binary log events</code>。</li><li>slave将master的<code>binary log events</code>拷贝到它的中继日志（relay log）</li><li>slave重做中继日志中的事件，将改变应用到自己的数据库中，MySQL复制是异步且串行化的。</li></ol><h3 id="复制原则"><a href="#复制原则" class="headerlink" title="复制原则"></a>复制原则</h3><ul><li>每个slave只能有一个master</li><li>买个slave只能有一个唯一的服务器ID</li><li>每个master可以有多个slave</li></ul><h3 id="复制的最大问题"><a href="#复制的最大问题" class="headerlink" title="复制的最大问题"></a>复制的最大问题</h3><p>延时</p><h3 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h3><ul><li>MySQL版本一致，且以后台服务运行</li><li>主从配置在[mysqld]节点下，都是小写</li><li>主机和从机都要关闭防火墙 service iptables stop 关闭linux防火墙</li></ul><blockquote><p>复习文件<br>二进制日志文件 </p><blockquote><p>log-bin 用于主从复制<br>log-err 记录mysql的错误日志<br>查询日志log 用于记录查询的sql语句</p></blockquote></blockquote><blockquote><p>数据文件</p><blockquote><p>frm文件 存放表结构<br>myd文件 存放表数据<br>myi文件 存放表索引</p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql(6) 连接查询</title>
      <link href="2021-02-01-4111.html"/>
      <url>2021-02-01-4111.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>连接查询又称多表查询，当查询字段来自于多个表时，就会用到连接查询</p><blockquote><p><strong>笛卡尔乘积现象</strong><br>表1有m行，表2有n行，结果=m*n行<br>发生原因:没有有效的连接条件<br>如何避免:添加有效的连接条件</p></blockquote><p>如何添加有效的连接查询，可分为几类：</p><ul><li>按年代分类：<ul><li>sql92标准:仅仅支持内连接</li><li>sql99标准【推荐】：支持内连接+外连接（左外和右外+交叉连接</li></ul></li><li>按功能分类：<ul><li>内连接：<ul><li>等值连接</li><li>非等值连接</li><li>自连接</li></ul></li><li>外连接：  <ul><li>左外连接</li><li>右外连接</li><li>全外连接</li></ul></li><li>交叉连接</li></ul></li></ul><h2 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h2><ul><li>多表等值连接的结果为多表的交集部分</li><li>n表连接，至少需要n-1个连接条件</li><li>多表的顺序没有要求</li><li>一般需要为表起别名</li><li>可以搭配前面介绍的所有子句使用，比如排序、分组、筛选</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql(5) 分组查询</title>
      <link href="2021-02-01-49117.html"/>
      <url>2021-02-01-49117.html</url>
      
        <content type="html"><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre class=" language-mysql"><code class="language-mysql">select 分组函数，列from 表[where 筛选条件]group by 分组的列表[order by 子句]</code></pre><p>注意，查询列表比较特殊，要求查询的列必须是group by 后出现的字段</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>分组查询中的筛选条件分为两类<table><thead><tr><th align="center"></th><th align="center">数据源</th><th align="center">位置</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">分组前筛选</td><td align="center">原始表</td><td align="center">group by子句前面</td><td align="center">where</td></tr><tr><td align="center">分组后筛选</td><td align="center">分组后的结果集</td><td align="center">group by子句后面</td><td align="center">having</td></tr></tbody></table></li></ol><ul><li>分组函数做条件，一定是放在having子句中</li><li>能在分组前筛选的，尽量不放在分组后筛选</li></ul><ol start="2"><li>group by支持单个字段分组和多个字段分组</li><li>也可添加排序，排序放在整个查询的最后</li></ol><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><ol><li><p>查询那个部门的员工个数&gt;2</p><pre class=" language-mysql"><code class="language-mysql">SELECT COUNT(*),department_idFROM employeesGROUP BY department_idHAVING COUNT(*)>2;``` mysql</code></pre></li><li><p>查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</p><pre class=" language-mysql"><code class="language-mysql">SELECT MAX(salary),job_idFROM employeesWHERE commission_pct IS NOT NULLGROUP BY job_idHAVING MAX(salary)>12000;</code></pre></li><li><p>查询领导编号&gt;102的每个领导手下的最低工资&gt;5000的领导编号是哪个，以及其最低工资</p><pre class=" language-mysql"><code class="language-mysql">SELECT MIN(salary),manager_idFROM employeesWHERE manager_id>102GROUP BY manager_idHAVING MIN(salary)>5000;</code></pre></li><li><p>按员工姓名的长度分组，查询每一组的员工个数，筛选员工个数&gt;5的有哪些 </p><pre class=" language-mysql"><code class="language-mysql">SELECT COUNT(*) c, LENGTH(last_name) lennameFROM employeesGROUP BY LENGTH(last_name)HAVING c>5;</code></pre></li><li><p>按多个字段分组<br>查询每个部门每个工种的员工的平均工资</p><pre class=" language-mysql"><code class="language-mysql">SELECT AVG(salary),department_id,job_idFROM employeesGROUP BY job_id,department_id;</code></pre></li><li><p>添加排序<br>查询每个部门每个工种的员工的平均工资，并且把平均工资&gt;10000的部门按平均工资的高低显示</p><pre class=" language-mysql"><code class="language-mysql">SELECT AVG(salary) a,department_id,job_idFROM employeesWHERE department_id IS NOT NULLGROUP BY job_id, department_idHAVING a>10000ORDER BY a DESC; </code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker(2) 常用命令行</title>
      <link href="2021-01-27-13.html"/>
      <url>2021-01-27-13.html</url>
      
        <content type="html"><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><pre class=" language-bash"><code class="language-bash">systemctl start docker <span class="token comment" spellcheck="true"># 启动docker</span></code></pre><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><pre class=" language-bash"><code class="language-bash">docker version   <span class="token comment" spellcheck="true"># 查询版本号</span>docker info     <span class="token comment" spellcheck="true"># 显示详细的docker的信息</span>docker --help   <span class="token comment" spellcheck="true"># 帮助命令</span></code></pre><h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><pre class=" language-bash"><code class="language-bash">docker images  <span class="token comment" spellcheck="true"># 查询本机存在的镜像</span>docker images -a <span class="token comment" spellcheck="true"># 列出本地所有的镜像，含中间映像层</span>docker images -q <span class="token comment" spellcheck="true"># 当前镜像的id</span>docker images -qa <span class="token comment" spellcheck="true"># 所有镜像的id</span>docker images --digests <span class="token comment" spellcheck="true">#显示摘要信息</span>docker images --no-trunc <span class="token comment" spellcheck="true"># 显示完整的id</span><span class="token comment" spellcheck="true"># </span>docker search hello-world <span class="token comment" spellcheck="true"># 查找镜像，官方镜像会有标识</span>docker search --filter<span class="token operator">=</span>stars<span class="token operator">=</span>3 --no-trunc busyboxdocker rmi hello-world <span class="token comment" spellcheck="true"># 删除镜像</span>docker rmi -f hello-world <span class="token comment" spellcheck="true"># 运行状态下强制删除</span>docker rmi -f c1 c2 c3 <span class="token comment" spellcheck="true"># 同时删除多个镜像</span><span class="token comment" spellcheck="true"># 组合命令</span>docker rmi -f <span class="token variable"><span class="token variable">$(</span>docker images -qa<span class="token variable">)</span></span>  <span class="token comment" spellcheck="true"># 删除所有镜像</span></code></pre><p><del>docker -s 30 tomcat # 筛选出stars在30以上的镜像</del></p><h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><p>有镜像才能创建容器</p><pre class=" language-bash"><code class="language-bash">docker run <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> image <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span> <span class="token punctuation">[</span>ARG<span class="token punctuation">..</span>.<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 新建容器</span><span class="token comment" spellcheck="true"># 例</span>docker run -it <span class="token punctuation">[</span>id<span class="token punctuation">]</span>   <span class="token comment" spellcheck="true"># 生成以目标id镜像为模板的容器，并且在登陆后自动生成一个伪终端。</span>docker run -it --name <span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 生成镜像且命名</span>docker run -it -p 8080:8080 tomcat <span class="token comment" spellcheck="true"># -p:主机端口：容器端口</span>docker run -it -P tomcar <span class="token comment" spellcheck="true">#-P:随机分配端口:容器端口</span></code></pre><p>OPTIONS说明(常用) :有些是一个减号，有些是两个减号<br>–name=”容器新名字”:为容器指定-一个名称;<br>-d: 后台运行容器，并返回容器ID，也即启动守护式容器;<br>-i: 以交互模式运行容器，通常与-t同时使用;<br>-t: 为容器重新分配一个伪输入终端，通常与-i同时使用;<br>-P: 随机端口映射;<br>-p: 指定端口映射，有以下四种格式<br>&emsp;ip:hostPort:containerPort<br>&emsp;ip::containerPort<br>&emsp;hostPort:containerPort<br>&emsp;containerPort</p><pre class=" language-bash"><code class="language-bash">docker <span class="token function">ps</span> <span class="token comment" spellcheck="true"># 查看所有正在运行的容器</span><span class="token comment" spellcheck="true"># 例</span>docker <span class="token function">ps</span> -l <span class="token comment" spellcheck="true"># 列出上一次运行的容器</span>docker <span class="token function">ps</span> -n 3 <span class="token comment" spellcheck="true"># 列出之前三次运行的容器</span>docker <span class="token function">ps</span> -lq <span class="token comment" spellcheck="true"># 列出上次运行的容器的编号</span></code></pre><p>OPTIONS说明(常用) :<br>    -a :列出当前所有正在运行的容器+历史上运行过的容器<br>    -l:显示最近创建的容器。<br>    -n:显示最近n个创建的容器。<br>    -q :静默模式， 只显示容器编号。<br>    –no-trunc :不截断输出。</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">exit</span> <span class="token comment" spellcheck="true">#关闭并退出容器</span>ctrl + P + Q <span class="token comment" spellcheck="true"># 退出但不关闭容器</span>docker start <span class="token punctuation">[</span>容器id<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 运行创建过的容器</span>docker restart <span class="token punctuation">[</span>容器id<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 重启容器</span>docker stop <span class="token punctuation">[</span>容器id<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 关闭容器</span>docker <span class="token function">kill</span> <span class="token punctuation">[</span>容器id<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 强制关闭容器</span>docker <span class="token function">rm</span> <span class="token punctuation">[</span>容器id<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 删除已停止的容器</span>docker <span class="token function">rm</span> -f <span class="token punctuation">[</span>容器id<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 强制删除</span>docker <span class="token function">rm</span> -f <span class="token variable"><span class="token variable">$(</span>docker <span class="token function">ps</span> -qa<span class="token variable">)</span></span><span class="token comment" spellcheck="true"># 批量删除</span>docker <span class="token function">ps</span> -qa <span class="token operator">|</span> <span class="token function">xargs</span> docker <span class="token function">rm</span> <span class="token comment" spellcheck="true"># 批量删除</span></code></pre><h3 id="容器命令-1"><a href="#容器命令-1" class="headerlink" title="容器命令"></a>容器命令</h3><pre class=" language-bash"><code class="language-bash">docker run -d <span class="token punctuation">[</span>镜像id<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 以守护式进程的方式启动，返回值为容器id</span><span class="token comment" spellcheck="true"># 但是执行上述命令之后发现容器已经退出</span><span class="token comment" spellcheck="true"># 这是因为：Docker容器后台运行， 就必须有一个前台进程。</span>docker run -d centos /bin/sh -c <span class="token string">"while true; do echo hello zzyy; sleep 2; done"</span> <span class="token comment" spellcheck="true"># 运行容器进程的同时，定时打印字符串，防止容器停止</span>docker logs -f -t --tail <span class="token punctuation">[</span>容器id<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 查看容器的日志</span><span class="token comment" spellcheck="true"># 不加[option]时，返回容器打印的东西，以上述代码为例。打印 'hello zzyy'</span><span class="token comment" spellcheck="true"># -t 打印时间+'hello zzyy'</span><span class="token comment" spellcheck="true"># -f 打印之前的logs,并且实时追加新的logs</span><span class="token comment" spellcheck="true"># --tail n 仅打印最后的n条logs</span>docker <span class="token function">top</span> <span class="token punctuation">[</span>容器id<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 查看容器内的进程</span>docker inspect <span class="token punctuation">[</span>容器id<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 查看容器内部的细节(json格式)</span>docker attach <span class="token punctuation">[</span>容器id<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 进入正在运行的容器并以命令行的形式进行交互</span>docker <span class="token function">exec</span> -t <span class="token punctuation">[</span>容器id<span class="token punctuation">]</span> <span class="token function">ls</span> -l /tmp <span class="token comment" spellcheck="true"># 直接获取容器内运行命令的结果，然后返回结果（在宿主机上控制容器）</span>docker <span class="token function">cp</span> <span class="token punctuation">[</span>容器id<span class="token punctuation">]</span>:容器内的路径  宿主机路径 <span class="token comment" spellcheck="true"># 从容器内拷贝文件到宿主机上</span></code></pre><h3 id="操作补充"><a href="#操作补充" class="headerlink" title="操作补充"></a>操作补充</h3><pre class=" language-bash"><code class="language-bash">docker commit <span class="token comment" spellcheck="true"># 提交容器，将其转换成新的镜像。</span>docker commit -m<span class="token operator">=</span><span class="token string">"提交的描述信息"</span> -a<span class="token operator">=</span>"作者“ </code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql(4) 常用函数</title>
      <link href="2021-01-24-53496.html"/>
      <url>2021-01-24-53496.html</url>
      
        <content type="html"><![CDATA[<p>函数的调用：</p><pre class=" language-mysql"><code class="language-mysql">SELECT 函数名(实参列表) FROM 表;</code></pre><p>分类：<br>1、单行函数：CONCAT,LENGTH,IFNULL<br>2、分组函数：用于统计，又称为统计函数、聚合函数、组函数</p><h2 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h2><h3 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h3><ol><li><p>length,获取参数值的    字节个数（与编码方式有关）</p><pre class=" language-mysql"><code class="language-mysql">SELECT LENGTH('John');SELECT LENGTH('测试中文132');</code></pre></li><li><p>concat,拼接字符串</p><pre class=" language-mysql"><code class="language-mysql">SELECT CONCAT(last_name,',',first_name) 姓名 FROM employees;</code></pre></li><li><p>upper,lower, 大小写转换</p><pre class=" language-mysql"><code class="language-mysql">SELECT UPPER('john');SELECT LOWER('JOHN');</code></pre></li><li><p>substr，substring，截取字符串，两个函数一样</p><pre class=" language-mysql"><code class="language-mysql">SELECT SUBSTR('123456',4) out_put;  # 截取第四个到结尾的字符。SELECT SUBSTR('123456',4, 1) out_put;  # 截取从第四个字符开始的指定长度的字符。</code></pre></li><li><p>姓名的首字符大写，其它字符小写，并用下划线拼接<br>``` mysql<br>SELECT<br> CONCAT(</p><pre><code> UPPER(SUBSTR( last_name, 1, 1 )), LOWER(SUBSTR( last_name, 2 )), &#39;_&#39;, UPPER(SUBSTR( first_name, 1, 1 )), LOWER(SUBSTR( first_name, 2))) out_put</code></pre><p>FROM employees;</p></li><li><p>instr,返回字串字串第一次在主串中出现的位置索引，如果找不到，返回0</p><pre class=" language-mysql"><code class="language-mysql">SELECT INSTR('123456789','456') AS out_put;</code></pre></li><li><p>trim,去前后的空格（中间的不去），可以去除指定的字符</p><pre class=" language-mysql"><code class="language-mysql">SELECT TRIM('                  23 4       ') AS out_put;SELECT TRIM('aa' FROM 'aavssacsaaaaa')</code></pre></li><li><p>lpad,用指定字符左填充指定长度</p><pre class=" language-mysql"><code class="language-mysql">SELECT LPAD('12354',10,'*');</code></pre></li><li><p>rpad，右填充</p><pre class=" language-mysql"><code class="language-mysql">SELECT RPAD('12354',10,'*');</code></pre></li><li><p>replace, 替换</p><pre class=" language-mysql"><code class="language-mysql">SELECT REPLACE('123456123456123789123','123','321');</code></pre><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3></li><li><p>round 四舍五入</p><pre class=" language-mysql"><code class="language-mysql">SELECT ROUND(-1.55);# -2</code></pre></li><li><p>ceil,向上取整</p><pre class=" language-mysql"><code class="language-mysql">SELECT CEIL(-1.05); # -1</code></pre></li><li><p>floor,向下取整</p><pre class=" language-mysql"><code class="language-mysql">SELECT FLOOR(-1.05); # -2</code></pre></li><li><p>truncate,截断，小数点后保留几位</p><pre class=" language-mysql"><code class="language-mysql">SELECT TRUNCATE(3.1415926,3); # 3.141</code></pre></li><li><p>mod，取余</p><pre class=" language-mysql"><code class="language-mysql">SELECT MOD(11,3);SELECT 10%3;</code></pre></li></ol><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><ol><li><p>now,返回当前系统日期+时间</p><pre class=" language-mysql"><code class="language-mysql">SELECT NOW();</code></pre></li><li><p>curdate，返回当前系统的日期</p><pre class=" language-mysql"><code class="language-mysql">SELECT CURDATE();</code></pre></li><li><p>curtime，返回当前系统的时间</p><pre class=" language-mysql"><code class="language-mysql">SELECT CURTIME();</code></pre></li><li><p>获取指定部分的日期。年、月、日、时、分、秒</p><pre class=" language-mysql"><code class="language-mysql">SELECT YEAR(NOW()) 年;SELECT YEAR('1998-05-26')SELECT YEAR(hiredate) 年 FROM employees;</code></pre></li><li><p>str_to_date,将日期类型的字符转换为指定格式的日期<br>格式:</p></li></ol><table><thead><tr><th align="center">序号</th><th align="center">格式符</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">%Y</td><td align="center">四位的年份</td></tr><tr><td align="center">2</td><td align="center">%y</td><td align="center">2位的年份</td></tr><tr><td align="center">3</td><td align="center">%m</td><td align="center">月份( 01,02..11,12 )</td></tr><tr><td align="center">4</td><td align="center">%c</td><td align="center">月份( 1,2..11,12 )</td></tr><tr><td align="center">5</td><td align="center">%d</td><td align="center">日( 01,02… )</td></tr><tr><td align="center">6</td><td align="center">%H</td><td align="center">小时( 24小时制)</td></tr><tr><td align="center">7</td><td align="center">%h</td><td align="center">小时( 12小时制)</td></tr><tr><td align="center">8</td><td align="center">%i</td><td align="center">分钟( 00,01…59 )</td></tr><tr><td align="center">9</td><td align="center">%s</td><td align="center">秒( 00,01,…,59 )</td></tr></tbody></table><pre class=" language-mysql"><code class="language-mysql"># 查询入职日期为1992-4-3的员工信息SELECT * FROM employees WHERE hiredate = '1992-4-3';SELECT * FROM employees WHERE hiredate = STR_TO_DATE('4-3-1992','%c-%d-%Y');</code></pre><ol start="6"><li>date_format,将日期转换为字符<pre class=" language-mysql"><code class="language-mysql">SELECT DATE_FORMAT(NOW(),'%y年%m月%d日') AS out_put;</code></pre></li></ol><h3 id="其它函数"><a href="#其它函数" class="headerlink" title="其它函数"></a>其它函数</h3><pre class=" language-mysql"><code class="language-mysql">SELECT VERSION();#查看数据库版本号SELECT DATABASE();# 查看当前使用的数据库SELECT USER(); # 查看当前登录的用户</code></pre><h3 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h3><ol><li><p>if函数，三元运算符的效果</p><pre class=" language-mysql"><code class="language-mysql">SELECT IF(10<9,'小','大');</code></pre></li><li><p>case函数，switch-cased的效果<br>格式：<br>case 要判断的字段或表达式/不写<br>when 常量1/条件 then 要显示的值1或语句1;<br>when 常量2/条件 then 要显示的值2或语句2;<br>else 要显示的值n或语句n;<br>end</p></li></ol><pre class=" language-mysql"><code class="language-mysql"># 查询员工的工资，要求部门号=30，显示的工资为1.1倍部门号=40，显示的工资为1.2倍部门号=50，显示的工资为1.3倍其他部门，显示的工资为原工资SELECT    salary 原始工资, department_id,CASE department_id     WHEN 30 THEN salary * 1.1     WHEN 40 THEN salary * 1.2     WHEN 50 THEN salary * 1.3     ELSE salary     END AS 新工资 FROM    employees;</code></pre><h2 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h2><ul><li>分类<ul><li>sum    求和</li><li>avg 平均值</li><li>max 最大值</li><li>min 最小值</li><li>count 计算不为null的数据的个数</li></ul></li></ul><ol><li><p>简单使用</p><pre class=" language-mysql"><code class="language-mysql">SELECT SUM(salary) FROM employees;SELECT AVG(salary) FROM employees;SELECT MIN(salary) FROM employees;SELECT MAX(salary) FROM employees;SELECT COUNT(salary) FROM employees;</code></pre></li><li><p>特点</p></li></ol><ul><li><p>支持的数据类型：</p><ul><li>sum, avg：数值型</li><li>max,min，count：数值、字符、日期（任何类型）</li></ul></li><li><p>是否忽略null值</p><ul><li>均忽略null值</li></ul></li></ul><ol start="3"><li><p>和distinct搭配去重</p><pre class=" language-mysql"><code class="language-mysql">SELECT SUM(DISTINCT salary) FROM employees;</code></pre></li><li><p>count函数详解</p><pre class=" language-mysql"><code class="language-mysql">SELECT COUNT(commission_pct) FROM employees;# 结果：35   统计某一字段SELECT COUNT(*)    FROM employees;# 结果：107  统计总行数，有任一字段不为空都会被统计SELECT COUNT(1) FROM employees; # 在原表基础上加了一个常量值，统计个数</code></pre></li><li><p>效率：<br>MYISAM存储引擎下， count(<em>)的效率最高<br>INNODB存储引擎下， count(</em>)和count(1)的效率并列第一<br>一般用count(*)</p></li></ol><p>注意：可以和分组函数以同查询的字段有限制,要求是group by后的字段。</p><hr>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL(3) DQL语言</title>
      <link href="2021-01-23-40177.html"/>
      <url>2021-01-23-40177.html</url>
      
        <content type="html"><![CDATA[<h2 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h2><p>格式：<code>SELECT 查询列表 FROM 表名</code>；<br>查询列表可以是：表中的字段、常量值、表达式、函数<br>查询的结果是一个虚拟的表格</p><p>建议在查询开始的地方选中目标数据库<code>USE myemployees;</code></p><ol><li><p>查询表中的单个字段</p><pre class=" language-mysql"><code class="language-mysql">SELECT last_name FROM employees;</code></pre></li><li><p>查询表中的多个字段</p><pre class=" language-mysql"><code class="language-mysql">SELECT last_name,salary,email FROM employees;</code></pre></li><li><p>查询表中的所有字段</p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM employees;</code></pre></li><li><p>如果字段名和关键字重名，要用``括起来</p><pre class=" language-mysql"><code class="language-mysql">SELECT `NAME` FROM stuifo;</code></pre></li><li><p>查询常量值</p><pre class=" language-mysql"><code class="language-mysql">SELECT 100;SELECT "John";</code></pre></li><li><p>查询表达式</p><pre class=" language-mysql"><code class="language-mysql">SELECT 100%98;</code></pre></li><li><p>查询函数</p><pre class=" language-mysql"><code class="language-mysql">SELECT VERSION();</code></pre></li><li><p>设置别名<br>作用：便于理解、区分重名</p><pre class=" language-mysql"><code class="language-mysql">SELECT 100%98 AS 结果;SELECT last_name AS 姓, first_name AS 名 FROM employees;</code></pre><p>简写</p><pre class=" language-mysql"><code class="language-mysql">SELECT last_name 姓,first_name 名 FROM employees;</code></pre><p>别名可以添加双引号,产生存在空格的别名</p><pre class=" language-mysql"><code class="language-mysql">SELECT salary AS "out put" FROM employees;</code></pre></li><li><p>去重（DISTINCT）</p><pre class=" language-mysql"><code class="language-mysql">SELECT DISTINCT department_id FROM employees;</code></pre></li><li><p>+号的作用<br>mysql中+号只有一个功能：运算符<br>“100”+90;字符型加数值型，则先将字符型转换成数值型。若转换成功，则加法运算。若转换失败，则转换为0<br>null + 数值型 = null<br>字符串拼接需要用函数<code>CONCAT()</code>.</p><pre class=" language-mysql"><code class="language-mysql">SELECTCONCAT(last_name, first_name ) AS 姓名 FROMemployees;</code></pre></li><li><p>拼接employee的全部列，并用逗号连接</p><pre class=" language-mysql"><code class="language-mysql">SELECT IFNULL( commission_pct, 0 ) AS 奖金率, commission_pct FROM employees;SELECTCONCAT(    first_name,    ',',    last_name,    ',',    job_id,    ',',IFNULL( commission_pct, 0 )) AS out_put FROMemployees;</code></pre></li></ol><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p><strong>语法</strong>：</p><pre class=" language-mysql"><code class="language-mysql">SELECT        查询列表FROM        表名WHERE        筛选条件;逐行筛选</code></pre><p><strong>执行顺序</strong>：<br>    1. from   先查看当前数据库有没有这张表<br>    2. where  筛选，筛选出满足要求的行<br>    3. select 查询需要的类</p><p><strong>分类</strong>：</p><ul><li>按条件表达式筛选<br>  条件运算符 ：&gt; &lt; = &lt;&gt; &gt;= &lt;=</li><li>按逻辑表达式筛选<br>  逻辑运算符：<ul><li>&amp;&amp; || !</li><li>and or not</li></ul></li><li>模糊查询</li><li>like</li><li>between and</li><li>in</li><li>is null</li></ul><ol><li><p>工资大于12000的员工信息</p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM employees WHERE salary > 12000;</code></pre></li><li><p>部门标号不等于90号的员工名和部门编号</p><pre class=" language-mysql"><code class="language-mysql">SELECT last_name, department_id FROM  employees WHERE department_id != 90; department_id <> 90;</code></pre></li><li><p>查询工资在10000到20000之间的员工名、工资和奖金</p><pre class=" language-mysql"><code class="language-mysql">SELECT last_name, salary, commission_pct FROM employees WHERE salary >= 10000  AND salary <= 20000;</code></pre></li><li><p>查询员工名中包含字符a的员工信息(默认不区分大小写)<br><code>like</code>一般和通配符搭配使用<br>通配符有：</p></li></ol><ul><li>%，任意多个字符，包含0个字符</li><li>—，任意单个字符<pre class=" language-mysql"><code class="language-mysql">SELECT  *FROM  employeesWHERE  last_name LIKE '%a%';</code></pre></li></ul><ol start="5"><li><p>查询员工名第三个字符为n,第五个字符为l的员工名</p><pre class=" language-mysql"><code class="language-mysql">SELECT last_nameFROM employeesWHERE last_name LIKE '__n_l%';</code></pre></li><li><p> 6.1. 查询第二个字符为_的员工名(转义运算符 )</p><pre class=" language-mysql"><code class="language-mysql">SELECTlast_nameFROMemployeesWHERElast_name LIKE '_\_%';</code></pre><p> 6.2. 也可以随意指定转义符</p><pre class=" language-mysql"><code class="language-mysql">SELECTlast_nameFROMemployeesWHERElast_name LIKE '_$_%' ESCAPE '$';</code></pre></li><li><p>查询员工编号在100到120之间的员工信息<br><code>between and</code>可以提高语句的简洁度，它包含两侧数指的临界值</p><pre class=" language-mysql"><code class="language-mysql">SELECT *FROM employeesWHERE department_id BETWEEN 100 AND 110;</code></pre></li><li><p>查询员工的工种编号是 ‘FI_MGR’, ‘FI_ACCOUNT’, ‘AC_MGR’, ‘AD_VP’的员工信息<br><code>in</code>:判断某字段的值是否属于in列表中的某一项<br>特点</p><ul><li>提高语句简介度</li><li>in列表中的值类型必须一致或兼容</li><li>in列表中不支持通配符<pre class=" language-mysql"><code class="language-mysql">SELECTlast_name,job_idFROMemployeesWHEREjob_id IN('FI_MGR', 'FI_ACCOUNT', 'AC_MGR', 'AD_VP');</code></pre></li></ul></li><li><p> 9.1. 查询没有奖金的员工名和奖金率<br><code>is null</code>: &lt; &gt; = 不能用于判断null值</p><pre class=" language-mysql"><code class="language-mysql">SELECT last_name, commission_pctFROM employeesWHERE commission_pct IS NULL;</code></pre><p> 9.2. 查询有奖金的员工名和奖金率</p><pre class=" language-mysql"><code class="language-mysql">SELECT last_name, commission_pctFROM employeesWHERE commission_pct IS NOT NULL;    </code></pre></li><li><p>安全等于  &lt;=&gt;</p><pre class=" language-mysql"><code class="language-mysql">SELECTlast_name,commission_pctFROMemployeesWHEREcommission_pct <=> NULL;    </code></pre></li></ol><p><strong>对比</strong><br><code>IS NULL</code> :仅仅可以判断null值，可读性较高<br><code>&lt;=&gt;</code> :既可以判断NULL值，也可以判断普通数值，但是可读性较低。建议用IS NULL</p><h2 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h2><p>语法：</p><pre class=" language-mysql"><code class="language-mysql">SELECT 查询列表FROM   表[WHERE 筛选条件]ORDER BY 排序列表 [ASC、DESC];</code></pre><p>特点：</p><ul><li>默认升序</li><li>ORDER BY 子句支持单个字段、多个字段、表达式、函数、别名的排序</li><li>ORDER BY 子句一般是放在查询语句的最后边。LIMIT子句除外。</li></ul><p>1.<br>    1.1 查询员工信息，要求工资从高到底排序</p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM employees ORDER BY salary DESC;</code></pre><pre><code>1.2 从低到高排序,ASC可省略，即默认排序是升序</code></pre><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM employees ORDER BY salary ASC;SELECT * FROM employees ORDER BY salary;</code></pre><ol start="2"><li><p>查询部门编号&gt;=90的员工信息，按入职时间排序</p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM employeesWHERE department_id >= 90ORDER BY hiredate ASC;</code></pre></li><li><p>按年薪的高低排序显示【按表达式排序】</p><pre class=" language-mysql"><code class="language-mysql">SELECT *, salary*12*(1+IFNULL(commission_pct,0)) AS 年薪FROM employeesORDER BY salary*12*(1+IFNULL(commission_pct,0));</code></pre></li><li><p>支持按别名排序</p><pre class=" language-mysql"><code class="language-mysql">SELECT *, salary*12*(1+IFNULL(commission_pct,0)) AS 年薪FROM employeesORDER BY 年薪;</code></pre></li><li><p>按姓名的长度显示员工的姓名和工资【按函数排序】</p><pre class=" language-mysql"><code class="language-mysql">SELECT LENGTH(last_name) 字节长度, last_name, salaryFROM employeesORDER BY 字节长度;</code></pre></li><li><p>先按工资排序，再按员工编号排序【按多个字段排序】</p><pre class=" language-mysql"><code class="language-mysql">SELECT *FROM employeesORDER BY salary ASC, employee_id DESC;</code></pre></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker(1) 简介和原理</title>
      <link href="2021-01-23-40175.html"/>
      <url>2021-01-23-40175.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h2><ul><li>强制：熟悉Linux命令和相关背景知识 <code>ps top</code></li><li>建议：Maven/git相关的知识 <code>git pull</code></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Docker是什么<br>为什么出现Docker?<br>开发人员能够运行的程序，更换电脑后无法正常运行。利用Docker可以把代码，环境配置等属性都复制过来。</li></ul><p>交付代码-&gt;交付镜像</p><p>解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。</p><ul><li>Docker能做什么？<br>Docker是基于虚拟机技术开发出来的<br>虚拟机模拟了一个完整的操作系统（硬件+软件），它的缺点：</li></ul><ol><li>资源占用多</li><li>冗余步骤多</li><li>启动慢</li></ol><p>基于这些缺点，发展了新的虚拟化技术：Linux容器（LXC）。</p><ul><li><p>开发/运维（DevOps）</p><ul><li>更快速的应用交付和部署</li><li>更便捷的升级和扩缩容</li><li>更简单的系统运维</li><li>更高效的计算资源利用</li></ul></li><li><p>Docker的三大要素</p></li><li><p>镜像：一个只读的模板，一个镜像可以创建多个容器</p></li><li><p>容器：用镜像创建的运行实例。每个容器都是相互隔离的、保证安全的平台。</p><ul><li>可以把容器看成一个简易版的Linux环境。</li><li>容器和镜像几乎一摸一样，但是容器的最上层是可写可读的</li></ul></li><li><p>仓库:集中存放镜像文件的场所</p><ul><li>仓库分为公开库和私有库，最大的公开仓库是Docker Hub,国内有阿里云、网易云的镜像<br>Docker本身是一个容器运行载体。我们打包的环境是image镜像文件，利用镜像文件可以生成多个载体。可以从仓库拉取需要的镜像文件。</li></ul></li><li><p>Docker为什么比VM快<br>(1) docker有着比虚拟机更少的抽象层。由亍Docker不需要Hypervisor实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上Docker将会在效率上有明显优势。<br>(2) Docker利用的是宿主机的内核,而不需要Guest 0S。因此，当新建一个容器时，Docker不需要和虚拟机一样重新加载- - 个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程，当新建–个虚拟机时，虚拟机软件需要加载GuestOS,返个新建过程是分钟级别的。而Docker由于直接利用宿主机的操作系统,则省略了返个过程，因此新建一个Docker容器只需要几秒钟。</p></li></ul><table><thead><tr><th align="center"></th><th align="center">Docker容器</th><th align="left">虚拟机(VM)</th></tr></thead><tbody><tr><td align="center">操作系统</td><td align="center">与宿主机共享OS</td><td align="left">宿主机OS上运行虚拟机OS</td></tr><tr><td align="center">存储大小</td><td align="center">镜像小，便于存储与传输</td><td align="left">镜像庞大(vmdk、vdi等)</td></tr><tr><td align="center">运行性能</td><td align="center">几乎无额外性能损失</td><td align="left">操作系统额外的CPU、内存消耗.</td></tr><tr><td align="center">移植性</td><td align="center">轻便、灵活，适应于Linux</td><td align="left">笨重,与虚拟化技术耦合度高</td></tr><tr><td align="center">硬件亲和性</td><td align="center">面向软件开发者</td><td align="left">面向硬件运维者</td></tr><tr><td align="center">部署速度</td><td align="center">快速，秒级</td><td align="left">较慢，10s以上</td></tr></tbody></table><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p><ul><li><p><strong>联合文件系统</strong><br>UnionFS (联合文件系统) : Union文件 系统(UnionFS)是一种分层、 轻量级并且高性能的文件系统，它支持对文件系线的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)，可以制作各种具体的应用镜像。</p></li><li><p><strong>docker镜像加载原理</strong></p><ul><li>bootfs(boot file system)主要包含bootloader和kernel, bootloader 主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这- - 层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权己由bootfs转交给内核，此时系统也会卸载bootfs。</li><li>rootfs (root file system)，在bootfs之 上。包含的就是典型Linux系统中的/dev, /proc, /bin, /etc等标准目录和文件。rootfs就 是各种不同的操作系统发行版，比如Ubuntu，Centos等等。<br>rootfs可以很小，只需要包括最基本的命令、工具和程序库即可，底层直接使用宿主机的内核。对于不同的linux发行版，bootfs一致，但是roorfs不同<br>docker的镜像是分层的，分层的最大的一个好处就是-共享资源比如:有多个镜像都从相同的base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，同时内存中也只需加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</li></ul></li></ul><ul><li><strong>特点</strong><br>Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL(2) Docker中安装MySQL</title>
      <link href="2021-01-23-40067.html"/>
      <url>2021-01-23-40067.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class=" language-cmd"><code class="language-cmd">docker pull mysql  # 拉取mysql镜像docker images # 查看镜像是否拉取成功</code></pre><p><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210123152529.png"></p><pre class=" language-bash"><code class="language-bash">docker run -itd --name mysql_01 -p 3306:3306 -e MYSQL_ROOT_PASSWORD<span class="token operator">=</span>123456 mysql</code></pre><p>创建容器。容器名为mysql_01,端口映射为3306，数据库密码为123456</p><h2 id="设置安全组"><a href="#设置安全组" class="headerlink" title="设置安全组"></a>设置安全组</h2><p>如果数据库安装在云服务器上，需要配置安全组，打开3306端口。当然，为了安全，也可以映射到其它端口号上。<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210123155152.png"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>打开数据库管理软件，新建连接-&gt; MySQL-&gt; 输入数据库信息-&gt; 连接<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210123155425.png"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL(1) 概述</title>
      <link href="2021-01-23-64410.html"/>
      <url>2021-01-23-64410.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="为什么学习数据库"><a href="#为什么学习数据库" class="headerlink" title="为什么学习数据库"></a>为什么学习数据库</h3><p>目前的数据容器：</p><ul><li>java中的集合 ：存于内存，易失性</li><li>文件 ：不便查询</li></ul><h3 id="DB、DBMS、SQL名词解释"><a href="#DB、DBMS、SQL名词解释" class="headerlink" title="DB、DBMS、SQL名词解释"></a>DB、DBMS、SQL名词解释</h3><ul><li>DB：数据库，存储数据的仓库；保存一组有组织的数据的容器</li><li>BDMS：数据库管理系统(MySQL、Oracle、SqlServer)</li><li>SQL：结构化查询语言；专门用来和数据库通讯的语言</li></ul><h3 id="数据库如何存储数据"><a href="#数据库如何存储数据" class="headerlink" title="数据库如何存储数据"></a>数据库如何存储数据</h3><ul><li>将数据放到表中，再把表放到库中。</li><li>一个数据库中可以有多个表</li><li>表由列组成，称为字段。</li><li>表中的数据按行存储，每一个类似于java中的“对象”。<h3 id="MySQL简介"><a href="#MySQL简介" class="headerlink" title="MySQL简介"></a>MySQL简介</h3></li></ul><ol><li>MySQL已经被oracle收购了</li><li>优点<ul><li>成本低</li><li>性能高</li><li>简单：易于安装和使用</li></ul></li></ol><h3 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h3><p>1、显示所有数据库</p><pre class=" language-mysql"><code class="language-mysql">SHOW DATABASES</code></pre><p>2、进入指定数据</p><pre class=" language-mysql"><code class="language-mysql">USE test</code></pre><p>3、显示当前数据库中的所有表</p><pre class=" language-mysql"><code class="language-mysql">SHOW TABLES</code></pre><p>4、显示指定数据库中的所有表</p><pre class=" language-mysql"><code class="language-mysql">SHOW TABLES FROM mysql</code></pre><p>5、查看当前所在的数据库</p><pre class=" language-mysql"><code class="language-mysql">SELECT DATABASE()</code></pre><p>6、查看表结构</p><pre class=" language-mysql"><code class="language-mysql">DESC stuifo;</code></pre><p>7、查看表中的数据</p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM stuifo;</code></pre><p>8、查看当前数据库的版本</p><pre class=" language-mysql"><code class="language-mysql">SELECT VERSION()</code></pre><h3 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h3><ol><li>不区分大小写，但是建议关键字大写，表明、列名小写</li><li>每条命令最好用分号结尾</li><li>每条命令根据需要可以进行缩进或换行</li><li>注释</li></ol><ul><li>单行注释：#注释文字</li><li>单行注释：– 注释文字</li><li>多行注释：/* 注释文字 */</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可以ping通，但是打不开网页</title>
      <link href="2021-01-22-12396.html"/>
      <url>2021-01-22-12396.html</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>最近电脑无法打开百度在内的所有网站，只有科学上网才能正常使用浏览器，非常麻烦。于是测试了一下，在cmd里输入</p><pre class=" language-cmd"><code class="language-cmd">ping www.baidu.com</code></pre><p>发现是可以ping通的<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210122115009.png"></p><p>直接使用ip地址也是可以访问的<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210122115155.png"><br>因此猜测是DNS出了问题，这时候突然想起来，之前由于需要使用学校的VPN，因此修改了自己的DNS配置。回到家里以后，应该是由于运营商变化，本来的DNS地址不能使用，才导致了这种情况。</p><blockquote><p>不同的ISP有不同的DNS地址，如果固定了DNS地址，可能导致无法访问。</p></blockquote><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>控制面板-&gt;网络和共享中心-&gt;更改适配器设置-&gt;右键当前使用的网络-&gt;属性<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210122115821.png"></p><p>选择Internet协议版本4（TCP/IPv4）-&gt;属性<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210122115936.png"><br>选择自动获取DNS服务器地址<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210122120123.png"><br>如果有必要，IPv6的DNS服务器地址也要尽心设置。</p><h3 id="其它情况"><a href="#其它情况" class="headerlink" title="其它情况"></a>其它情况</h3><ul><li>本地的DNS缓存出现错误，也会导致网站无法访问。cmd运行一下命令，重建本地DNS缓存<pre class=" language-cmd"><code class="language-cmd">ipconfig /flushdns</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch(2) 在ECS上安装ElasticSearch+ik分词器</title>
      <link href="2021-01-20-46171.html"/>
      <url>2021-01-20-46171.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装ElasticSearch"><a href="#安装ElasticSearch" class="headerlink" title="安装ElasticSearch"></a>安装ElasticSearch</h2><p>ElasticSearch的安装在1中已经介绍过了，详见<a href="/2021-01-17-46483">安装ElasticSearch+添加ik分词</a>。这里主要讲解CentOS和Windows下的不同之处。</p><h2 id="配置安全组"><a href="#配置安全组" class="headerlink" title="配置安全组"></a>配置安全组</h2><p>要想本地访问ECS上的ElasticSearch服务，必须在配置安全组，打开相应的端口号。<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210118185702.png"><br>添加端口9200<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210118185742.png"><br>将安全组设置添加到服务器上<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210118185930.png"></p><h2 id="添加分词器"><a href="#添加分词器" class="headerlink" title="添加分词器"></a>添加分词器</h2><h3 id="把插件文件移动到ECS中"><a href="#把插件文件移动到ECS中" class="headerlink" title="把插件文件移动到ECS中"></a>把插件文件移动到ECS中</h3><p>下载<code>putty</code>，打开<code>psftp.exe</code><br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210118183209.png"><br>连接云服务器，输入账号密码：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">open</span> <span class="token punctuation">[</span>自己服务器的公网ip<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 输入账号密码</span></code></pre><p><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210118184141.png"><br><code>Remote working directory is /root</code>显示了是当前的工作路径<br>把本地插件文件复制到ECS中</p><pre class=" language-bash"><code class="language-bash">put -r e:/image/Mysql/elasticsearch-analysis-ik-7.10.2/ik/ /root/ik</code></pre><p>进入阿里云提供的控制台<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210118184749.png"></p><p>可以看到，文件已经存在于云服务器中<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210118184825.png"><br>把文件从云服务器复制到es容器中，重启容器。</p><pre class=" language-bash"><code class="language-bash">docker <span class="token function">cp</span> ik/ <span class="token punctuation">[</span>容器id<span class="token punctuation">]</span>:/usr/share/elasticsearch/pluginsdocker restart <span class="token punctuation">[</span>容器id<span class="token punctuation">]</span></code></pre><h2 id="Postman测试"><a href="#Postman测试" class="headerlink" title="Postman测试"></a>Postman测试</h2><p><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210118190441.png"></p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> ik分词器 </tag>
            
            <tag> ECS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建个人博客(2) 博客文章管理</title>
      <link href="2021-01-20-16176.html"/>
      <url>2021-01-20-16176.html</url>
      
        <content type="html"><![CDATA[<h2 id="hexo设置"><a href="#hexo设置" class="headerlink" title="hexo设置"></a>hexo设置</h2><h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><ul><li><p><strong>创建新文章或者新页面</strong></p><pre class=" language-bash"><code class="language-bash">hexo new post <span class="token operator">&lt;</span>title<span class="token operator">></span>    <span class="token comment" spellcheck="true"># 在source/_posts下创建新的名称为&lt;title>的文章，模板是scaffolds/post</span>hexo new draft <span class="token operator">&lt;</span>title<span class="token operator">></span>   <span class="token comment" spellcheck="true"># 在source/_drafts下创建名称为&lt;title>的文章,模板是scaffolds/draft</span></code></pre></li><li><p><strong>也可以通过<code>--path</code>指定生成的路径</strong></p><pre class=" language-bash"><code class="language-bash">hexo new post <span class="token punctuation">..</span>/_drafts/hexo/test <span class="token comment" spellcheck="true"># 在source/_drafts/hexo 下创建名为test的文章，模板是scaffolds/post</span></code></pre><p>如果不希望主题对文章进行处理，可以在顶部添加<code>layout：false</code></p></li><li><p><strong>从草稿发布到正式文章</strong></p><pre class=" language-bash"><code class="language-bash">hexo publish 文章文件名</code></pre><p>也可手动将<code>_drafts</code>目录下的草稿移动到<code>_posts</code>目录下。</p></li><li><p><strong>文件名称</strong><br>Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。</p></li><li><p><strong>草稿</strong><br>草稿中的文章可以通过<code>publish</code>命令移动到<code>source/_drafts</code>文件夹中</p><pre class=" language-bash"><code class="language-bash">hexo publish <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">></span></code></pre><p>把<code>config.yml</code>中的<code>render_drafts</code>设置为<code>true</code>可以预览草稿，也可以通过<code>hexo s --draft</code>在运行时启用预览草稿</p></li><li><p><strong>模板(Scaffold)</strong><br><code>scaffolds</code> 文件夹内存放了模板<br>在新建文章时，Hexo 会根据模板建立文件</p><pre class=" language-bash"><code class="language-bash">hexo new photo <span class="token string">"My Gallery"</span></code></pre></li></ul><h3 id="设置格式"><a href="#设置格式" class="headerlink" title="设置格式"></a>设置格式</h3><ul><li><p><strong>Front-matter</strong><br>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量<br><a href="https://hexo.io/zh-cn/docs/front-matter">https://hexo.io/zh-cn/docs/front-matter</a></p></li><li><p><strong>分类和标签</strong><br>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p></li><li><p><strong>标签插件</strong><br>标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件<br>内容较多，类似于各种前端组件，需要的时候再查吧</p><h2 id="创建文章的命令"><a href="#创建文章的命令" class="headerlink" title="创建文章的命令"></a>创建文章的命令</h2><pre class=" language-bash"><code class="language-bash">hexo new <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">></span> <span class="token comment" spellcheck="true"># 新建一篇文章，如果没有设置layout的话，默认使用`_config.yml`中的`default_layout`参数代替，如果命名中包含空格，需要用引号括起来。</span>hexo new <span class="token string">"hello world"</span> <span class="token comment" spellcheck="true"># 新建文章，文章被放在 source/_posts/hello-world.md</span>hexp new draft <span class="token string">"hello world"</span> <span class="token comment" spellcheck="true"># 新建草稿，草稿被放在 source/_drafts/hello-world.md</span></code></pre><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>-p</code>, <code>--path</code></td><td align="center">自定义新文章的路径</td></tr><tr><td align="center"><code>-r</code>, <code>--replace</code></td><td align="center">如果存在同名文章，将其替换</td></tr><tr><td align="center"><code>-s</code>, <code>--slug</code></td><td align="center">文章的 Slug，作为新文章的文件名和发布后的 URL`</td></tr></tbody></table></li></ul><pre class=" language-bash"><code class="language-bash">hexo new draft --path <span class="token punctuation">..</span>/_drafts/Docker/测试  <span class="token comment" spellcheck="true"># 在指令路径创建名称为“测试”的草稿</span></code></pre><h3 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h3><h4 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h4><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。<br>|配置选项|    默认值|    描述|<br>|:—-:|:—-:|:—-|<br>|title    |Markdown 的文件标题    |文章标题，强烈建议填写此选项|<br>|date    |文件创建时的日期时间    |发布时间，强烈建议填写此选项，且最好保证全局唯一|<br>|author    |根 <code>_config.yml</code> 中的 <code>author</code>    |文章作者|<br>|img    |<code>featureImages</code> 中的某个值    |文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code>|<br>|top    |true    |推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章|<br>|cover    |false    |v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中|<br>|coverImg    |无|    v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片|<br>|password    |无    |文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 |SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项<br>|toc    |true    |是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项|<br>|mathjax    |false    |是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行|<br>|summary    |无    |文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要|<br>|categories    |无    |文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类|<br>|tags    |无    |文章标签，一篇文章可以多个标签|</p><ol><li>如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。</li><li>date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。</li></ol><h4 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h4><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token punctuation">---</span></code></pre><h4 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h4><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 赵奇<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/1.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Typora  <span class="token punctuation">-</span> Markdown<span class="token punctuation">---</span></code></pre><h3 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h3><p>主题的 <code>_config.yml</code>可以修改部分，该文件中有注释，自行查看</p><h4 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h4><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 .<code>bg-color</code> 来修改背景颜色：</p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */</span><span class="token number">.</span>bg-color &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right, <span class="token hexcode">#4cbf30</span> <span class="token number">0%</span>, <span class="token hexcode">#0f9d58</span> <span class="token number">100%</span><span class="token punctuation">)</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token atrule"><span class="token rule">@-webkit-keyframes</span> rainbow &amp;#123<span class="token punctuation">;</span></span>   <span class="token comment" spellcheck="true">/* 动态切换背景颜色. */</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token atrule"><span class="token rule">@keyframes</span> rainbow &amp;#123<span class="token punctuation">;</span></span>    <span class="token comment" spellcheck="true">/* 动态切换背景颜色. */</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><h4 id="修改-banner-图和文章特色图"><a href="#修改-banner-图和文章特色图" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h4><p>你可以直接在 <code>/source/medias/banner</code> 文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 7 张即可。如果你会 JavaScript 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.bg-cover'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'background-image'</span><span class="token punctuation">,</span> <span class="token string">'url(/medias/banner/'</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.jpg)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p>]]></content>
      
      
      <categories>
          
          <category> 个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> hexo-theme-matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建个人博客(1) 本地运行hexo并更换matery主题</title>
      <link href="2021-01-18-26979.html"/>
      <url>2021-01-18-26979.html</url>
      
        <content type="html"><![CDATA[<h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p><a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p><h2 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p>先行条件，事先安装</p><ul><li>Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li>Git</li></ul></li><li><p>全局安装hexo</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli</code></pre></li><li><p>执行hexo<br>方式一、<code>npx hexo &lt;command&gt;</code><br>方式二、略</p></li><li><p>生成文件<br>安装 Hexo 完成后，执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><pre class=" language-bash"><code class="language-bash">hexo init <span class="token operator">&lt;</span>folder<span class="token operator">></span><span class="token function">cd</span> <span class="token operator">&lt;</span>folder<span class="token operator">></span><span class="token function">npm</span> <span class="token function">install</span></code></pre></li><li><p>运行站点</p><pre class=" language-bash"><code class="language-bash">hexo server <span class="token comment" spellcheck="true"># 运行站点</span>hexo s  <span class="token comment" spellcheck="true"># 缩写</span></code></pre><p><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210120162919.png"></p></li></ul><p>新建完成后，项目的文件夹目录如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">.</span>├── _config.yml├── package.json├── scaffolds├── <span class="token function">source</span><span class="token operator">|</span>   └── _posts└── themes</code></pre><ul><li><p>文件介绍</p><ul><li><p>_config.yml<br>  网站的 配置 信息，可以在此配置大部分的参数。</p></li><li><p>package.json<br>  应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，可以自由移除。</p></li><li><p>scaffolds<br>  模版 文件夹。新建文章时，Hexo 会根据 <code>scaffold</code> 来建立文件。<br>  系统默认提供了三个模板<code>draft</code>,<code>page</code>,<code>post</code></p></li><li><p>source<br>  资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p></li><li><p>themes</p><ol><li>主题 文件夹。Hexo 会根据主题来生成静态页面。</li><li>主题的配置文件里放置的配置会覆盖主题目录下的 _config.yml 中的配置</li><li>Hexo 在合并主题配置时，Hexo 配置文件中的 <code>theme_config</code> 的优先级最高，其次是 <code>_config.[theme].yml</code> 文件，最后是位于主题目录下的 <code>_config.yml</code> 文件。</li></ol></li></ul></li></ul><h3 id="hexo的详细配置"><a href="#hexo的详细配置" class="headerlink" title="hexo的详细配置"></a>hexo的详细配置</h3><p><a href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a></p><h3 id="hexo的常用指令"><a href="#hexo的常用指令" class="headerlink" title="hexo的常用指令"></a>hexo的常用指令</h3><p><a href="https://hexo.io/zh-cn/docs/commands">https://hexo.io/zh-cn/docs/commands</a></p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>hexo的官网<a href=""></a>上可以查到许多的主题，可以根据自己的喜好自行挑选，然后根据主题进行针对性的修改。<br>本文使用的是的主题是<code>matery</code>，<code>matery</code>是一个采用<code>Material Design</code>和响应式设计的 Hexo 博客主题。主题演示可以看<a href="https://blinkfox.github.io/">这里</a>。点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master">这里</a> 下载 master 分支的最新稳定版的代码，解压缩后，将 hexo-theme-matery 的文件夹复制到你 Hexo 的 themes 文件夹中即可。<br>也可以在你的 themes 文件夹下使用 Git clone 命令来下载:</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/blinkfox/hexo-theme-matery.git</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h4><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的 theme 的值：theme: <code>hexo-theme-matery</code>。此时，重启站点即可渲染成新的主题。<br><code>_config.yml</code> 文件的其它修改建议:</p><ul><li>修改 _config.yml 的 url 的值为你的网站主 URL（如：<a href="http://xxx.github.io)./">http://xxx.github.io）。</a></li><li>建议修改两个 per_page 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改 language 的值为 zh-CN</li></ul><h4 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h4><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"categories"</span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> categories<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token punctuation">---</span></code></pre><h4 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h4><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 source 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"tags"</span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> tags<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 18:23:38</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token punctuation">---</span></code></pre><p>_config.yml 文件的其它修改建议:</p><h4 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h4><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"about"</span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> about<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token punctuation">---</span></code></pre><h4 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h4><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <code>hexo-prism-plugin</code> 的 Hexo 插件来做代码高亮，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i -S hexo-prism-plugin</code></pre><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prism_plugin</span><span class="token punctuation">:</span>  <span class="token key atrule">mode</span><span class="token punctuation">:</span> <span class="token string">'preprocess'</span>    <span class="token comment" spellcheck="true"># realtime/preprocess</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'tomorrow'</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">false    </span><span class="token comment" spellcheck="true"># default false</span>  custom_css<span class="token punctuation">:</span></code></pre><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><p>主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post</code></pre><h4 id="中文链接转拼音（可选的）"><a href="#中文链接转拼音（可选的）" class="headerlink" title="中文链接转拼音（可选的）"></a>中文链接转拼音（可选的）</h4><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin Hexo</a> 插件使在生成文章时生成中文拼音的永久链接。<br>安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i hexo-permalink-pinyin --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">permalink_pinyin</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> <span class="token comment" spellcheck="true"># default: '-'</span></code></pre><p>除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a> 插件也可以生成非中文的链接</p><h4 id="文章字数统计插件（可选的）"><a href="#文章字数统计插件（可选的）" class="headerlink" title="文章字数统计插件（可选的）"></a>文章字数统计插件（可选的）</h4><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。<br>安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i --save hexo-wordcount</code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，激活以下配置项即可：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">wordCount</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 将这个值设置为 true 即可.</span>  <span class="token key atrule">postWordCount</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><h4 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h4><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h4 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h4><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱的配置，你可以在主题文件的 /layout/<code>_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://github.com/blinkfox<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tooltipped<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span> <span class="token attr-name">data-tooltip</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>访问我的GitHub<span class="token punctuation">"</span></span> <span class="token attr-name">data-position</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span> <span class="token attr-name">data-delay</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-github<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span></code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a href="https://fontawesome.com/icons">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fa-facebook</code></li><li>Twitter: <code>fa-twitter</code></li><li>Google-plus: <code>fa-google-plus</code></li><li>Linkedin: <code>fa-linkedin</code></li><li>Tumblr: <code>fa-tumblr</code></li><li>Medium: <code>fa-medium</code></li><li>Slack: <code>fa-slack</code></li><li>新浪微博: <code>fa-weibo</code></li><li>微信: <code>fa-wechat</code></li><li>QQ: <code>fa-qq</code><h4 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h4>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片</li></ul><h4 id="配置音乐播放器（可选的）"><a href="#配置音乐播放器（可选的）" class="headerlink" title="配置音乐播放器（可选的）"></a>配置音乐播放器（可选的）</h4><p>要支持音乐播放，就必须开启音乐的播放配置和音乐数据的文件。</p><p>首先，在你的博客 <code>source</code> 目录下的 <code>_data</code> 目录（没有的话就新建一个）中新建 <code>musics.json</code> 文件，文件内容如下所示：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">[</span>&amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"五月雨变奏电音"</span><span class="token punctuation">,</span>    <span class="token property">"artist"</span><span class="token operator">:</span> <span class="token string">"AnimeVibe"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://xxx.com/music1.mp3"</span><span class="token punctuation">,</span>    <span class="token property">"cover"</span><span class="token operator">:</span> <span class="token string">"http://xxx.com/music-cover1.png"</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Take me hand"</span><span class="token punctuation">,</span>    <span class="token property">"artist"</span><span class="token operator">:</span> <span class="token string">"DAISHI DANCE,Cecile Corbel"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"/medias/music/music2.mp3"</span><span class="token punctuation">,</span>    <span class="token property">"cover"</span><span class="token operator">:</span> <span class="token string">"/medias/music/cover2.png"</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Shape of You"</span><span class="token punctuation">,</span>    <span class="token property">"artist"</span><span class="token operator">:</span> <span class="token string">"J.Fla"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://xxx.com/music3.mp3"</span><span class="token punctuation">,</span>    <span class="token property">"cover"</span><span class="token operator">:</span> <span class="token string">"http://xxx.com/music-cover3.png"</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">]</span></code></pre><p>以上 JSON 中的属性：name、artist、url、cover 分别表示音乐的名称、作者、音乐文件地址、音乐封面。<br>然后，在主题的 _config.yml 配置文件中激活配置即可：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 是否在首页显示音乐.</span><span class="token key atrule">music</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">showTitle</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">title</span><span class="token punctuation">:</span> 听听音乐  <span class="token key atrule">fixed</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 是否开启吸底模式</span>  <span class="token key atrule">autoplay</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 是否自动播放</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> '<span class="token comment" spellcheck="true">#42b983'</span>  <span class="token key atrule">loop</span><span class="token punctuation">:</span> <span class="token string">'all'</span> <span class="token comment" spellcheck="true"># 音频循环播放, 可选值: 'all', 'one', 'none'</span>  <span class="token key atrule">order</span><span class="token punctuation">:</span> <span class="token string">'list'</span> <span class="token comment" spellcheck="true"># 音频循环顺序, 可选值: 'list', 'random'</span>  <span class="token key atrule">preload</span><span class="token punctuation">:</span> <span class="token string">'auto'</span> <span class="token comment" spellcheck="true"># 预加载，可选值: 'none', 'metadata', 'auto'</span>  <span class="token key atrule">volume</span><span class="token punctuation">:</span> <span class="token number">0.7 </span><span class="token comment" spellcheck="true"># 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效</span>  <span class="token key atrule">listFolded</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 列表默认折叠</span>  <span class="token key atrule">listMaxHeight</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 列表最大高度</span></code></pre><h2 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h2><ul><li><strong>Todo</strong></li></ul><p>配置完成后发布的指令</p><pre class=" language-bash"><code class="language-bash">hexo cleanhexo ghexo s</code></pre>]]></content>
      
      
      <categories>
          
          <category> 个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> hexo-theme-matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch(1) Win10+Docker下安装ElasticSearch</title>
      <link href="2021-01-17-46483.html"/>
      <url>2021-01-17-46483.html</url>
      
        <content type="html"><![CDATA[<h2 id="在Docker中安装ElasticSearch"><a href="#在Docker中安装ElasticSearch" class="headerlink" title="在Docker中安装ElasticSearch"></a>在Docker中安装ElasticSearch</h2><pre class=" language-bash"><code class="language-bash">docker pull docker.elastic.co/elasticsearch/elasticsearch:7.10.0 <span class="token comment" spellcheck="true"># 拉取es镜像文件</span>docker run -p 9200:9200 -p 9300:9300 -e <span class="token string">"discovery.type=single-node"</span> -e <span class="token string">"ES_JAVA_OPTS=-Xms256m -Xmx512m"</span> --name es -d docker.elastic.co/elasticsearch/elasticsearch:7.10.0 <span class="token comment" spellcheck="true"># 启动单个节点集群，限制容器大小，命名为es，后台运行</span></code></pre><p>执行成功后可以用<code>docker ps</code>可以看到容器正在运行中<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210118003401.png"></p><p>并且可以打开链接进行测试<a href="http://localhost:9200/">http://localhost:9200/</a><br>如果出现下图的情况，则说明ElasticSearch的容器已经运行成功了。<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210118003019.png"></p><h2 id="在ElasticSearch中添加ik分词器"><a href="#在ElasticSearch中添加ik分词器" class="headerlink" title="在ElasticSearch中添加ik分词器"></a>在ElasticSearch中添加ik分词器</h2><p>Elasticsearch中默认提供了一个标准分词器，但是该分词器对中文并不友好，该分词处理中文时是一元分词器。因此需要在ElasticSearch中添加新的分词器插件（本文以ik分词器为例）。</p><ol><li><p>下载和ElasticSearch配套的ik插件<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a>。并将解压后将文件夹重名为<code>ik</code>。<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210118004705.png"></p></li><li><p>进入容器</p><pre class=" language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it 8cf1c /bin/bash <span class="token comment" spellcheck="true"># 其中8cf1c为容器id</span></code></pre><p>运行结果：<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210118003937.png"></p></li><li><p>进入插件目录，可以看到插件目录是空的</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> <span class="token punctuation">..</span><span class="token function">cd</span> <span class="token punctuation">..</span><span class="token function">cd</span> /usr/share/elasticsearch/plugins/  <span class="token comment" spellcheck="true"># 返回根目录后进入插件目录</span></code></pre><p><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210118004338.png"></p></li><li><p>将插件文件夹复制到容器内,并重启容器</p><pre class=" language-bash"><code class="language-bash">docker <span class="token function">cp</span> e:\elasticsearch\ik 8cf1c:\usr\share\elasticsearch\plugins <span class="token comment" spellcheck="true"># 第一个路径是本机路径，第二个路径是容器的文件路径，8cf1c是运行中的es容器</span>docker restart 8cf1c</code></pre><p>用Postman测试分词效果，可以看到标准分词的结果是一元分词，ik分词的结果不是一元分词。<br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210118005616.png"><br><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210118005520.png"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> ElasticSearch </tag>
            
            <tag> ik分词器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown常用命令</title>
      <link href="2020-12-22-123.html"/>
      <url>2020-12-22-123.html</url>
      
        <content type="html"><![CDATA[<h1 id="MarkDown"><a href="#MarkDown" class="headerlink" title="MarkDown"></a>MarkDown</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 一级标题</span><span class="token comment" spellcheck="true">## 二级标题</span><span class="token comment" spellcheck="true">### 三级标题</span><span class="token comment" spellcheck="true">#### 四级标题</span><span class="token comment" spellcheck="true">##### 五级标题</span><span class="token comment" spellcheck="true">###### 六级标题</span></code></pre><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><pre class=" language-bash"><code class="language-bash">*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___</code></pre><p>示例<br><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><strong><em>粗斜体文本</em></strong>  </p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><pre class=" language-bash"><code class="language-bash">**** * ******- - -----------</code></pre><p>效果</p><hr><hr><hr><hr><hr><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><pre class=" language-bash"><code class="language-bash">~~删除~~</code></pre><p><del>该段文字已被删除</del></p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>u<span class="token operator">></span>带下划线文本<span class="token operator">&lt;</span>/u<span class="token operator">></span></code></pre><p><u>带下划线文本</u></p><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>不同的软件有不同书写方式<br>（这里暂时没找到可用的形式）</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容</p><pre class=" language-bash"><code class="language-bash">* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><p>有序列表使用数字并加上 . 号来表示，如：</p><pre class=" language-bash"><code class="language-bash">1. 第一项2. 第二项3. 第三项</code></pre><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p><pre class=" language-bash"><code class="language-bash">1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素        - 二级嵌套</code></pre><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素<ul><li>二级嵌套</li></ul></li></ul></li></ol><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> 最外层<span class="token operator">></span> <span class="token operator">></span> 第一层嵌套<span class="token operator">></span> <span class="token operator">></span> <span class="token operator">></span> 第二层嵌套</code></pre><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><p>列表区块可以相互嵌套</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">`</span>printf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token variable">`</span></span> 函数</code></pre><p><code>printf()</code> 函数</p><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>代码区块使用 4 个空格或者一个制表符（Tab 键）。</p><pre><code>代码区块使用 4 个空格或者一个制表符（Tab 键）。</code></pre><p>你也可以用 ``` 包裹一段代码，并指定一种语言，当然，也可以不指定语言</p><pre class=" language-bash"><code class="language-bash">``` javascript<span class="token variable"><span class="token variable">$(</span>document<span class="token variable">)</span></span>.ready<span class="token punctuation">(</span>function <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    alert<span class="token punctuation">(</span><span class="token string">'RUNOOB'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;);</span></code></pre><p><em>效果</em></p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'RUNOOB'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>链接名称<span class="token punctuation">]</span><span class="token punctuation">(</span>链接地址<span class="token punctuation">)</span>或者<span class="token operator">&lt;</span>链接地址<span class="token operator">></span></code></pre><p><em>效果</em><br><a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">链接名称</a><br>或者<br>&lt;链接地址&gt;</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><pre class=" language-bash"><code class="language-bash"><span class="token operator">!</span><span class="token punctuation">[</span>图1<span class="token punctuation">]</span><span class="token punctuation">(</span>https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210118145754.png<span class="token punctuation">)</span></code></pre><p><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/20210118145754.png" alt="图1"></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><pre class=" language-bash"><code class="language-bash"><span class="token operator">|</span>  表头   <span class="token operator">|</span> 表头  <span class="token operator">|</span><span class="token operator">|</span>  ----  <span class="token operator">|</span> ----  <span class="token operator">|</span><span class="token operator">|</span> 单元格  <span class="token operator">|</span> 单元格 <span class="token operator">|</span><span class="token operator">|</span> 单元格  <span class="token operator">|</span> 单元格 <span class="token operator">|</span></code></pre><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p><strong>设置对齐方式</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token operator">|</span> 左对齐 <span class="token operator">|</span> 右对齐 <span class="token operator">|</span> 居中对齐 <span class="token operator">|</span><span class="token operator">|</span> :-----<span class="token operator">|</span> ----: <span class="token operator">|</span> :----: <span class="token operator">|</span><span class="token operator">|</span> 单元格 <span class="token operator">|</span> 单元格 <span class="token operator">|</span> 单元格 <span class="token operator">|</span><span class="token operator">|</span> 单元格 <span class="token operator">|</span> 单元格 <span class="token operator">|</span> 单元格 <span class="token operator">|</span></code></pre><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格左对齐</td><td align="right">单元格右对齐</td><td align="center">单元格居中对齐</td></tr><tr><td align="left">单元格左对齐</td><td align="right">单元格右对齐</td><td align="center">单元格居中对齐</td></tr></tbody></table><h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><h3 id="支持的-HTML-元素"><a href="#支持的-HTML-元素" class="headerlink" title="支持的 HTML 元素"></a>支持的 HTML 元素</h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。<br>目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等</p><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>Markdown 使用反斜杠转义特殊字符</p><pre class=" language-bash"><code class="language-bash">显示*号  \*显示\号  \\12345<span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>12345</code></pre><p>效果：<br>*<br>\<br>12345&nbsp;12345</p><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现</p><pre class=" language-latex"><code class="language-latex"><span class="token equation string">$$</span><span class="token function selector">\dfrac</span><span class="token punctuation">&amp;</span>#123;2<span class="token punctuation">&amp;</span>#125;<span class="token punctuation">&amp;</span>#123;4<span class="token punctuation">&amp;</span>#125; = 0.5 <span class="token function selector">\qquad</span> <span class="token function selector">\dfrac</span><span class="token punctuation">&amp;</span>#123;2<span class="token punctuation">&amp;</span>#125;<span class="token punctuation">&amp;</span>#123;c + <span class="token function selector">\dfrac</span><span class="token punctuation">&amp;</span>#123;2<span class="token punctuation">&amp;</span>#125;<span class="token punctuation">&amp;</span>#123;d + <span class="token function selector">\dfrac</span><span class="token punctuation">&amp;</span>#123;2<span class="token punctuation">&amp;</span>#125;<span class="token punctuation">&amp;</span>#123;4<span class="token punctuation">&amp;</span>#125;<span class="token punctuation">&amp;</span>#125;<span class="token punctuation">&amp;</span>#125; = a<span class="token equation string">$$</span><span class="token equation string">$$</span><span class="token function selector">\dbinom</span><span class="token punctuation">&amp;</span>#123;n<span class="token punctuation">&amp;</span>#125;<span class="token punctuation">&amp;</span>#123;r<span class="token punctuation">&amp;</span>#125;=<span class="token function selector">\binom</span><span class="token punctuation">&amp;</span>#123;n<span class="token punctuation">&amp;</span>#125;<span class="token punctuation">&amp;</span>#123;n-r<span class="token punctuation">&amp;</span>#125;=<span class="token function selector">\mathrm</span><span class="token punctuation">&amp;</span>#123;C<span class="token punctuation">&amp;</span>#125;_n^r=<span class="token function selector">\mathrm</span><span class="token punctuation">&amp;</span>#123;C<span class="token punctuation">&amp;</span>#125;_n^<span class="token punctuation">&amp;</span>#123;n-r<span class="token punctuation">&amp;</span>#125;<span class="token equation string">$$</span></code></pre><p>$$<br>\dfrac{2}{4} = 0.5 \qquad \dfrac{2}{c + \dfrac{2}{d + \dfrac{2}{4}}} = a<br>$$<br>$$<br>\dbinom{n}{r}=\binom{n}{n-r}=\mathrm{C}_n^r=\mathrm{C}_n^{n-r}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#(3) 接口、泛型</title>
      <link href="2020-12-07-9.html"/>
      <url>2020-12-07-9.html</url>
      
        <content type="html"><![CDATA[<h2 id="struct类型"><a href="#struct类型" class="headerlink" title="struct类型"></a>struct类型</h2><ul><li>struct值类型,class引用类型</li><li>struct不支持继承（隐式继承了object）</li><li>不可以写无参构造函数、不可以初始化</li></ul><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><ul><li>public</li><li>internal</li><li>private   默认</li><li>probtected</li><li>probtected internal    2、4的联合</li></ul><p>朋友程序集（程序集 Assembly）</p><ul><li>通过添加<code>System.Runtime.CompilerServices.InternalsVisibleTo</code>,并指定朋友程序集的名字，就可以把internal的成员暴露给朋友程序集<br>[assembly: InternalsVisibleTo(“Friend”)]</li><li>如果朋友assembly有Strong name,就必须指定其完整的160字节的public ket<br>[assembly: InternalsVisibleTo(“StrongFriend, PublicKey= 0652098a51c5487b…”)]</li><li>经常在单元测试时使用</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul><li><p>接口的成员都是隐式public，不可以声明访问修饰符</p></li><li><p>可以隐式转换将实现了接口A的对象，转换为接口A</p></li><li><p><code>ctrl + .</code>快速实现接口</p></li><li><p>接口的扩展，接口可以继承其它的接口</p></li></ul><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><ul><li>枚举的底层变量是int</li><li>枚举的值和底层对应的整型数值转换需要<strong>显式转换</strong></li><li>枚举中的0不需要显式转换</li></ul><h2 id="组合枚举"><a href="#组合枚举" class="headerlink" title="组合枚举"></a>组合枚举</h2><p>通过 <code>|</code> 和 <code>&amp;</code> 操作符<br><code>BorderSides leftRight = BorderSides.Left | BorderSides.Right</code></p><p>如果枚举类型可组合的话，应该使用<code>Flags</code>属性</p><pre class=" language-c#"><code class="language-c#">枚举的输出[Flags]public enum BorderSides &#123;None=0, Left=2,&#125;</code></pre><h1 id="泛型简介"><a href="#泛型简介" class="headerlink" title="泛型简介"></a>泛型简介</h1><ul><li><p>跨类型可复用的代码：继承 和 泛型</p></li><li><p>泛型 -》 使用带占位符的模板</p></li><li><p>只有类型和方法可以引入类型参数，其他属性不能引入，但是可以使用类型参数</p></li><li><p>可以有多个类型参数</p></li><li><p>泛型类型和泛型方法可以被重载</p></li></ul><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><ul><li>默认情况下，泛型可以是任何类型的</li><li>也可以指定约束</li></ul><ul><li><p><strong>协变</strong> 当值作为返回值输出时发生<br>public interface IEnumberable/<out T/></p></li><li><p><strong>逆变</strong> 当值作为输入时发生<br>public delegate void Action/<in T/></p></li><li><p><strong>不变</strong> 当值即使输入又是输出时发生<br>public interface IList/<T/></p></li></ul><p>东西太多了，不想看了</p><h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#(2) 类</title>
      <link href="2020-12-04-8.html"/>
      <url>2020-12-04-8.html</url>
      
        <content type="html"><![CDATA[<h1 id="创建类型"><a href="#创建类型" class="headerlink" title="创建类型"></a>创建类型</h1><ul><li><p>关键词 <code>readonly</code> 防止数据在构造之后被改变</p></li><li><p>方法 一个方法最好只做一件事</p><ul><li>方法的简写<pre class=" language-c#"><code class="language-c#">int Foo(int x) &#123; return x * 2&#125;int Foo (int x) => x*2;        //简写，仅适用于单表达式</code></pre></li><li>方法的重载   <ul><li>  按值传递和按引用传递的方法构成重载</li></ul></li></ul></li><li><p>构造函数和析构函数</p><ul><li><p>c#7.0 开始允许使用简写形式</p></li><li><p>构造函数的重载</p></li><li><p>如果没有定义构造函数，自动生成无参的构造函数，如果定义了任意一个构造函数，则不自动生成</p></li><li><p>生成构造函数的快捷键  <code>ctor + tab两下</code></p></li><li><p>可以定义非public的构造函数（<strong>单例模式</strong>）</p></li><li><p><strong>析构函数</strong>,方法名必须是deconstruct，且有一个或多个out参数</p></li></ul></li><li><p>this引用</p></li><li><p>属性和字段</p><ul><li>属性比字段多一个 {get; set;}块</li><li>属性可以加一些逻辑判断再复制</li><li>c#6 添加了属性初始化器   <code>public decimal CurrentPrice = &#123;get; set;&#125; = 125;</code></li><li>get、set可以拥有不同的访问级别</li></ul></li><li><p>索引器</p><ul><li>s[0],用法类似于访问数组</li><li>s?[],s==null时不会抛出异常</li><li>实现索引器</li></ul></li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul><li><p>向上转换-隐式转换（子类赋值给父类）向下转换-显示转换（父类赋值给字类），都是引用赋值</p></li><li><p>is</p><pre class=" language-c#"><code class="language-c#">用户向下转换前的验证if(a is Parent)&#123;&#125;</code></pre><pre class=" language-c#"><code class="language-c#">Parent pif(a is Parent)&#123;  p = (Parent)a;&#125;</code></pre><p>简写为</p><pre class=" language-c#"><code class="language-c#">if(a is Parent p)&#123;&#125;</code></pre></li></ul><h2 id="virtual函数成员"><a href="#virtual函数成员" class="headerlink" title="virtual函数成员"></a>virtual函数成员</h2><ul><li><p>标记为virtual 的函数可以被字类重写，包括方法、属性、索引器、事件</p></li><li><p>重写时使用override修饰符</p><pre class=" language-c#"><code class="language-c#">public class Asset&#123;    public virtual decimal Liability => 0;&#125;public class Stock:Asset&#123;    public decimal Mortgage;    public override decimal Liability => Mortgage;&#125;</code></pre><ul><li>重写方法里可以使用base关键字调用父类的实现</li><li>不建议在构造函数里调用virtual方法</li></ul></li></ul><h2 id="抽象类和抽象成员"><a href="#抽象类和抽象成员" class="headerlink" title="抽象类和抽象成员"></a>抽象类和抽象成员</h2><p>使用abstract声明的类是抽象类<br>抽象成员不提供实现，必须由字类进行实现（实现时仍然需要使用override）</p><ul><li>当子类父类都定义了相同的成员时，父类的成员会被隐藏掉，但是编译器会发出警告</li><li>使用new修饰符可以去除上述警告</li></ul><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><ul><li><p>Object是所有类型的终极父类</p></li><li><p>所有类型都可以向上转换为object</p></li><li><p>object是引用类型，值类型可以转换为object类型，反之亦然（<strong>类型统一</strong>）</p></li><li><p>值类型和object转化时，需要进行装箱和拆箱</p></li><li><p><strong>装箱</strong> 把值类型转换为引用类型，目标可以是object,也可以是某个接口</p><pre class=" language-c#"><code class="language-c#">int x = 9;object obj = x;</code></pre></li><li><p><strong>拆箱</strong></p><pre class=" language-c#"><code class="language-c#">object obj = 9;     //9的类型推断是int，int装箱long x = (long)obj; //抛出异常，因为类型不一致（要求为int）long x = (int)obj; //转化成功，拆箱成为int，int再隐式转换为long</code></pre></li><li><p>数组和泛型只支持引用转换，不支持装箱</p></li><li><p>装箱是复制数据，不是复制指针</p></li><li><p>静态和运行时的类型检查</p></li><li><p>所有的内置类型都重写了tostring()方法.自定义的类型也可以重写，不重写就会返回类型名</p></li></ul><h2 id="object成员列表"><a href="#object成员列表" class="headerlink" title="object成员列表"></a>object成员列表</h2><pre class=" language-c#"><code class="language-c#">        //        // 摘要:        //     Initializes a new instance of the System.Object class.        public Object();        //        // 摘要:        //     Allows an object to try to free resources and perform other cleanup operations        //     before it is reclaimed by garbage collection.        ~Object();        //        // 摘要:        //     Determines whether the specified object instances are considered equal.        //        // 参数:        //   objA:        //     The first object to compare.        //        //   objB:        //     The second object to compare.        //        // 返回结果:        //     true if the objects are considered equal; otherwise, false. If both objA and        //     objB are null, the method returns true.        public static bool Equals(Object? objA, Object? objB);        //        // 摘要:        //     Determines whether the specified System.Object instances are the same instance.        //        // 参数:        //   objA:        //     The first object to compare.        //        //   objB:        //     The second object to compare.        //        // 返回结果:        //     true if objA is the same instance as objB or if both are null; otherwise, false.        public static bool ReferenceEquals(Object? objA, Object? objB);        //        // 摘要:        //     Determines whether the specified object is equal to the current object.        //        // 参数:        //   obj:        //     The object to compare with the current object.        //        // 返回结果:        //     true if the specified object is equal to the current object; otherwise, false.        public virtual bool Equals(Object? obj);        //        // 摘要:        //     Serves as the default hash function.        //        // 返回结果:        //     A hash code for the current object.        public virtual int GetHashCode();        //        // 摘要:        //     Gets the System.Type of the current instance.        //        // 返回结果:        //     The exact runtime type of the current instance.        public Type GetType();        //        // 摘要:        //     Returns a string that represents the current object.        //        // 返回结果:        //     A string that represents the current object.        public virtual string? ToString();        //        // 摘要:        //     Creates a shallow copy of the current System.Object.        //        // 返回结果:        //     A shallow copy of the current System.Object.        protected Object MemberwiseClone();</code></pre>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#(1) c#基础知识</title>
      <link href="2020-12-03-7.html"/>
      <url>2020-12-03-7.html</url>
      
        <content type="html"><![CDATA[<h1 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h1><p>C# 7.0 in a nutshell<br>C# in depth</p><h1 id="c-简介"><a href="#c-简介" class="headerlink" title="c# 简介"></a>c# 简介</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li><p>类和接口</p><ul><li>Class</li><li>Interface</li><li>C#不支持多继承，所以需要多继承的时候需要用到接口</li></ul></li><li><p>属性、方法、事件</p></li><li><p>函数可以当作值来对待</p><ul><li>委托</li></ul></li><li><p>支持纯模式</p><ul><li>避免使用值可变的变量</li></ul></li><li><p>类型安全</p><ul><li>静态类型</li><li>支持动态类型</li><li>强类型</li></ul></li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ul><li>CLR公共语言运行时<ul><li>GC垃圾回收器</li></ul></li><li>C#中仍然存在指针<ul><li>但是通常情况下不需要使用指针</li><li>使用指针时需要用 <code>unsafe</code>标记</li></ul></li></ul><h2 id="平台支持"><a href="#平台支持" class="headerlink" title="平台支持"></a>平台支持</h2><ul><li><p>基于.NET Core可以运行于各个平台</p></li><li><p>.NET/.NET Core的核心时CLR:公共语言运行时</p></li><li><p>CLR与语言无关</p></li></ul><h2 id="支持C-的框架"><a href="#支持C-的框架" class="headerlink" title="支持C#的框架"></a>支持C#的框架</h2><ul><li>.NET Framework</li><li>.NET Core</li><li>Unity</li><li>UWP</li><li>Sql Server</li><li>…</li></ul><h1 id="C-基础知识"><a href="#C-基础知识" class="headerlink" title="C#基础知识"></a>C#基础知识</h1><ul><li><p>.NET Core 包括</p><ul><li>CLR 公共语言运行时</li><li>FCL 常用函数（文件操作，http连接等等）</li></ul></li><li><p>第三方库的平台<br>Nuget</p></li><li><p>C#编译器可以把.cs结尾的文件编译成Assembly</p></li><li><p>Assembly是.NET Core里的包装和部署单元</p></li><li><p>Assembly可以是应用程序，也可以是库</p><ul><li>—-.exe—-</li><li>.dll (在bin文件夹下)</li></ul></li></ul><p>obj里是一些临时文件，bin和obj文件都可以随意删除</p><ul><li><p>标识符</p><ul><li>强行使用关键字做标识符可以用@   如 <code>@class</code></li></ul></li><li><p>上下文关键字</p><ul><li></li></ul></li><li><p>静态类</p><ul><li>非静态类里可以有静态属性和非静态属性</li><li>静态类内只能有静态属性和非静态属性</li><li>静态类不能创建实例</li></ul></li><li><p>隐式转换的条件</p><ul><li>编译器保证可以转换成功</li><li>转换不会有损失</li></ul></li><li><p>显式转换的条件</p><ul><li>编译器不能保证可以转换成功</li><li>转换会有损失</li></ul></li></ul><p>分类<br>    值类型    总是复制赋值<br>    引用类型    赋值时仅复制地址值<br>    泛型<br>    指针</p><ul><li><p>内置类型</p><ul><li>除decimal以外的内置类型都叫做原始类型</li><li>System.IntPtr和System.UIntPtr也是原始类型</li></ul></li><li><p>数值类型</p><ul><li>数值赋值时可以使用下划线,例如：<br><code>int million = 1_000_000;</code></li><li>类型推断（小数-&gt;double,整数-&gt;可容纳该值的最小类型）</li><li><code>checked</code>关键字可令加减乘除抛出异常,来检查溢出<br>``` git<br>checked<br>{<br>  int d = a * b;<br>}</li><li>1.0/0.0 = Infinity</li><li>1.0/-0.0 = -Infinity</li><li>0.0/0.0 = NaN<br>```</li></ul></li><li><p>NaN 不等于任何值，包括NaN本身</p></li><li><p>使用object.Equals()时，两个NaN相等<br>验证某个值是否为NaN,可以使用<code>float.IsNan()</code>,<code>double.IsNan()</code><br>decimal非常适合财务计算</p></li></ul><h3 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h3><p>可空值类型除了可以表示正常数据，还可以表示null,使用方法<br><code>Nullable&lt;int&gt; indexOfM = null</code><br>简写 <code>int？ indexOfM = null</code></p><p>空字符串 null、空 “”、空白字符串” (space)  “</p><ul><li>Nullable&lt;T&gt;的常用属性和方法<ul><li>.HasValue     //null:false</li><li>.Value//T的值</li><li>.GetValueOrDefault()//T的值或者T的默认值</li><li>.GetValueOrDefault(默认值)//T的值或者指定的默认值</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git(4) 指令总结</title>
      <link href="2020-11-19-4.html"/>
      <url>2020-11-19-4.html</url>
      
        <content type="html"><![CDATA[<h1 id="git-指令"><a href="#git-指令" class="headerlink" title="git 指令"></a>git 指令</h1><pre class=" language-git"><code class="language-git">git add &amp;#123;file&amp;#125; 添加修改到暂存区git commit -m <span class="token string">"&amp;#123;备注&amp;#125;"</span>  讲暂存区的文件提交，生成新的版本git status 查看文件的变化git log     查看版本记录git reflog  查看历史修改记录git reset --hard HEAD^      重置会上个版本git reset --hard &amp;#123;标识号&amp;#125;   重置会目标版本，可只写版本号的前几位，git会自动追踪git checkout --&amp;#123;file&amp;#125;   恢复到暂存区中的文件，如果暂存区没有文件，则恢复到上个版本。但是不能连续撤回git rm --&amp;#123;file&amp;#125;     从版本库中删除某个文件（需要再git commit）</code></pre><p><strong>远程仓库</strong></p><p>通过<code>git bash</code>设置<code>ssh</code>  略</p><p><code>git remote add origin git@github.com:hou2529994315/TestGit.git</code>        添加远程库，远程库的名字叫做<code>origin</code></p><ul><li>首次推送<br><code>git push -u origin master</code>     把当前分支<code>master</code>推送到远程</li></ul><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了-u参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><ul><li>再次推送<br><code>git push origin master</code>        由于已经关联，不在需要<code>-u</code></li></ul><p><strong>从远程库克隆</strong><br><code>git clone &#123;自己的地址&#125;</code><br>GitHub给出的地址不止一个，还可以用<a href="https://github.com/michaelliao/gitskills.git%E8%BF%99%E6%A0%B7%E7%9A%84%E5%9C%B0%E5%9D%80%E3%80%82%E5%AE%9E%E9%99%85%E4%B8%8A%EF%BC%8CGit%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%9A%84git://%E4%BD%BF%E7%94%A8ssh%EF%BC%8C%E4%BD%86%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8https%E7%AD%89%E5%85%B6%E4%BB%96%E5%8D%8F%E8%AE%AE%E3%80%82">https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。</a></p><p><code>git checkout -b dev</code>       新建分支dev  <code>-b</code>参数表示创建并切换分支</p><p><code>git checkout &#123;分支名&#125;</code>      切换分支</p><p><code>git branch</code>            列出所有分支，当前分支前面会标一个*号</p><pre class=" language-git"><code class="language-git">git branch* dev  master</code></pre><p><code>git merge &#123;分支名&#125;</code>     把另一个分支的内容合并到当前分支</p><pre class=" language-git"><code class="language-git">git merge devUpdating 6409e7d..5a66c95Fast-forward readme.txt | 4 +++- 1 file changed, 3 insertions(+), 1 deletion(-)</code></pre><p>Fast-forward`告诉我们，这次合并是“快进模式”,合并完成后，就可以放心地删除dev分支了</p><p><code>git branch -d &#123;分支名&#125;</code>        删除分支</p><p>由于切换分支使用<code>git checkout &lt;branch&gt;</code>,而前面讲过的撤销修改则是<code>git checkout -- &lt;file&gt;</code>,两者是同一个命令，有点迷惑，所以最新版的Git提供了新的<code>git switch</code>命令来切换分支</p><p><code>git switch -c dev</code>         创建并切换到新的dev分支<br><code>git switch master</code>         直接切换到已有的master分支</p><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>如果新建了一个分支，并且新的分支和<code>master</code>都进行了修改，就会编程下边这样</p><p><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/2020-11-19-15-48-22.png"></p><p>此时使用合并指令的时候会提示存在冲突</p><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容<br>如：</p><pre class=" language-git"><code class="language-git">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.>>>>>>> feature1</code></pre><p>修改冲突部分再次使用<code>git add </code>, <code>git commit</code>进行提交，即可完成两者的合并</p><p>并且可以使用带参数的<code>git log</code>查看分支的合并情况<br><code>git log --graph --pretty=oneline --abbrev-commit</code></p><pre class=" language-bash"><code class="language-bash">*   4322cf0 conflict fixed<span class="token operator">|</span>\  <span class="token operator">|</span> * 94fa7a9 AND simple* <span class="token operator">|</span> a0932ce <span class="token operator">&amp;</span> simple<span class="token operator">|</span>/  * 5a66c95 branch <span class="token function">test</span>* 6409e7d 测试第二次推送到远程仓库* 85971d1 测试提交到远程仓库* 5b01d46 remove test.txt* 994e55e add test.txt* 60ceb97 测试checkout* 9b98464 <span class="token function">git</span> tracks changes* 40beaac understand how stage works* e37aa43 append GPL* 409a7d1 add distributed* 2f68874 <span class="token function">write</span> a readme <span class="token function">file</span></code></pre><p>合并后删除分支文件即可</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>如果可以，git会默认使用<code>Fast forward</code>模式进行合并，但是这样会丢失分支信息<br>可以使用<code>--no-ff</code>禁用<code>Fast forward</code>模式</p><p><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code></p><p>正常情况下，应该有一个稳定的<code>master</code>分支，发布新版本才用；有一个干活的<code>dev</code>分支；每个人有一个自己的分支，然后不定时的往<code>dev</code>分支合并</p><p><code>git stash</code>     保存工作现场<br><code>git stash list</code>    查看现有的工作现场<br><code>git stash apply</code>   恢复工作现场，但是需要使用  <code>git stash drop</code>来删除<br><code>git stash pop</code>     恢复工作现场的同时删除它</p><p>如果有多个工作现场，也可以指定恢复哪一个</p><pre class=" language-git"><code class="language-git">git stash apply stash@&amp;#123;0&amp;#125;</code></pre><p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p><h2 id="团队合作"><a href="#团队合作" class="headerlink" title="团队合作"></a>团队合作</h2><p>队友的最新提交和你试图提交的文件有冲突<br>先用<code>git pull</code>把最新的提交抓取下来，然后在本地合并，解决冲突，再提交上去</p><p><strong>暂时没有遇到，记录一下</strong></p><pre class=" language-git"><code class="language-git">git pullThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details.    git pull &lt;remote> &lt;branch>If you wish to set tracking information for this branch you can do so with:    git branch --set-upstream-to=origin/&lt;branch> devgit pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接git branch --set-upstream-to=origin/dev devBranch <span class="token string">'dev'</span> set up to track remote branch <span class="token string">'dev'</span> from <span class="token string">'origin'</span>.再pull：git pullAuto-merging env.txtCONFLICT (add/add): Merge conflict in env.txtAutomatic merge failed; fix conflicts and then commit the result.</code></pre><h2 id="变基（rebase）"><a href="#变基（rebase）" class="headerlink" title="变基（rebase）"></a>变基（rebase）</h2><h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2>]]></content>
      
      
      <categories>
          
          <category> 版本控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git(3) 远程仓库</title>
      <link href="2020-11-17-3.html"/>
      <url>2020-11-17-3.html</url>
      
        <content type="html"><![CDATA[<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p><strong>提交到远程仓库</strong><br>在本地的<code>learngit</code>仓库下运行命令</p><pre class=" language-git"><code class="language-git">git remote add origin git@github.com:michaelliao/learngit.git</code></pre><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><pre class=" language-git"><code class="language-git">git push -u origin masterCounting objects: 20, done.Delta compression using up to 4 threads.Compressing objects: 100% (15/15), done.Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.Total 20 (delta 5), reused 0 (delta 0)remote: Resolving deltas: 100% (5/5), done.To github.com:michaelliao/learngit.git * [new branch]      master -> masterBranch <span class="token string">'master'</span> set up to track remote branch <span class="token string">'master'</span> from <span class="token string">'origin'</span>.</code></pre><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数<br>Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>从现在起，只要本地作了提交，就可以通过命令,把本地<code>master</code>分支的最新修改推送至GitHub：</p><pre class=" language-git"><code class="language-git">git push origin master</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p><p>关联后，使用命令<code>git push -u origin master</code>第一次推送<code>master</code>分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改</p>]]></content>
      
      
      <categories>
          
          <category> 版本控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git(2) 修改版本</title>
      <link href="2020-11-17-2.html"/>
      <url>2020-11-17-2.html</url>
      
        <content type="html"><![CDATA[<h1 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h1><h2 id="查看修改信息"><a href="#查看修改信息" class="headerlink" title="查看修改信息"></a>查看修改信息</h2><p>修改文件，运行<code>git status</code>命令看看结果</p><pre class=" language-git"><code class="language-git">git statusOn branch masterChanges not staged for commit:  (use <span class="token string">"git add &lt;file>..."</span> to update what will be committed)  (use <span class="token string">"git checkout -- &lt;file>..."</span> to discard changes in working directory)    modified:   readme.txtno changes added to commit (use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span>)</code></pre><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。</p><p><code>git diff</code>可以看到详细的修改</p><pre class=" language-git"><code class="language-git">git diff readme.txt diff --git a/readme.txt b/readme.txtindex 46d49bf..9247db6 100644<span class="token deleted">--- a/readme.txt</span><span class="token inserted">+++ b/readme.txt</span><span class="token coord">@@ -1,2 +1,2 @@</span><span class="token deleted">-Git is a version control system.</span><span class="token inserted">+Git is a distributed version control system.</span> Git is free software.</code></pre><p><strong>总结</strong><br><code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容</p><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p><code>git log</code>命令显示从最近到最远的提交日志。</p><pre class=" language-git"><code class="language-git">git logcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -> master)Author: Michael Liao &lt;askxuefeng@gmail.com>Date:   Fri May 18 21:06:15 2018 +0800    append GPL<span class="token commit_sha1">commit e475afc93c209a690c39c13a46716e8fa000c366</span>Author: Michael Liao &lt;askxuefeng@gmail.com>Date:   Fri May 18 21:03:36 2018 +0800    add distributed<span class="token commit_sha1">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span>Author: Michael Liao &lt;askxuefeng@gmail.com>Date:   Fri May 18 20:59:18 2018 +0800    wrote a readme file</code></pre><p>嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数</p><pre class=" language-git"><code class="language-git">git log --pretty=oneline1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -> master) append GPLe475afc93c209a690c39c13a46716e8fa000c366 add distributedeaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</code></pre><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>如果需要回退，可以使用<code>git reset</code>命令</p><pre class=" language-git"><code class="language-git">git reset --hard HEAD^HEAD is now at e475afc add distributed</code></pre><p>回退以后，再使用<code>git log</code>就无法看到回退的版本了，因此如果想撤销回退，需要使用<code>git reset --hard 1094a</code><br><code>1094a</code>是版本号，但是版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p><p>如果忘记了版本号，可以使用<code>git reflog</code>查看版本号</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p><code>HEA</code>D指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</p></li><li><p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</p></li><li><p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p></li></ul><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p>工作区（Working Directory）</p><ul><li>电脑里直接看到的目录</li></ul><p>版本库（Repository），包括两个部分</p><ul><li>暂存区(stage 或者叫index)</li><li>Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code></li></ul><p><img src="https://gitee.com/ghost_building_puppet_master/img-hosting/raw/master/img/2020-11-18-14-08-08.png"></p><p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；<br>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：<br><code>it status On branch master nothing to commit, working tree clean</code></p><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p><code>git checkout -- file</code>可以丢弃工作区的修改</p><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令</p><p>用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p>]]></content>
      
      
      <categories>
          
          <category> 版本控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git(1) 创建版本库</title>
      <link href="2020-11-16-1.html"/>
      <url>2020-11-16-1.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><ul><li><p>git只能记录文本文件的变化</p></li><li><p>强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持</p></li><li><p>千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等</p></li></ul><p>第一步、进入一个空目录<br>第二步、通过<code>git init</code>命令把这个目录变成Git可以管理的仓库</p><pre class=" language-git"><code class="language-git">输入：git init输出：Initialized empty Git repository in /Users/michael/learngit/.</code></pre><p><strong>提交文件到版本库</strong><br>第一步，把文件添加到仓库</p><pre class=" language-git"><code class="language-git">git add readme.txt</code></pre><p>第二步，把文件提交到仓库</p><pre class=" language-git"><code class="language-git">git commit -m <span class="token string">"wrote a readme file"</span></code></pre><p><code>-m</code>面输入的是本次提交的说明,可以输入任意内容，当然最好是有意义的</p><p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）</p><p>一个<code>commit</code>可以提交很多个文件，所以可以先<code>add</code>多个文件，再提交</p><pre class=" language-git"><code class="language-git">git add file1.txtgit add file2.txt file3.txtgit commit -m <span class="token string">"add 3 files."</span></code></pre><h2 id="疑难解答"><a href="#疑难解答" class="headerlink" title="疑难解答"></a>疑难解答</h2><p>Q：输入<code>git add readme.txt</code>，得到错误：<code>fatal: not a git repository (or any of the parent directories)</code>。</p><p>A：Git命令必须在Git仓库目录内执行（<code>git init</code>除外），在仓库目录外执行是没有意义的。</p><p>Q：输入<code>git add readme.txt</code>，得到错误<code>fatal: pathspec &#39;readme.txt&#39; did not match any files</code>。</p><p>A：添加某个文件时，该文件必须在当前目录下存在，用<code>ls</code>或者<code>dir</code>命令查看当前目录的文件，看看文件是否存在，或者是否写错了文件名。</p>]]></content>
      
      
      <categories>
          
          <category> 版本控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
